package json

// Autogenerated using generate_sentinel_ast_walker.js
// DO NOT MODIFY MANUALLY
//
// This is not most effecient or quickest way to deserialize from JSON
// to an AST, but it works!

import (
	"encoding/json"
	"fmt"

	"github.com/glennsarti/sentinel-parser/sentinel_config/ast"
)

type rawJsonObject struct {
	AstType    string                     `json:"_t"`
	Properties map[string]json.RawMessage `json:"_p"`
}

func (jc *jsonCoder) read(data []byte) (ast.Node, error) {
	raw := rawJsonObject{}
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	switch raw.AstType {
	case "Feature":
		return jc.readFeature(raw)
	case "File":
		return jc.readFile(raw)
	case "Global":
		return jc.readGlobal(raw)
	case "Mock":
		return jc.readMock(raw)
	case "MockModule":
		return jc.readMockModule(raw)
	case "Parameter":
		return jc.readParameter(raw)
	case "Policy":
		return jc.readPolicy(raw)
	case "SentinelOptions":
		return jc.readSentinelOptions(raw)
	case "Test":
		return jc.readTest(raw)
	case "TestRule":
		return jc.readTestRule(raw)
	case "V1ModuleImport":
		return jc.readV1ModuleImport(raw)
	case "V1PluginImport":
		return jc.readV1PluginImport(raw)
	case "V2ModuleImport":
		return jc.readV2ModuleImport(raw)
	case "V2PluginImport":
		return jc.readV2PluginImport(raw)
	case "V2StaticImport":
		return jc.readV2StaticImport(raw)

	default:
		return nil, fmt.Errorf("Unknown type %q while deserializing", raw.AstType)
	}
}

func (jc *jsonCoder) readInto(data []byte, into ast.Node) error {
	result, err := jc.read(data)
	if err != nil {
		return err
	}

	switch intoActual := into.(type) {
	case *ast.Feature:
		if resultActual, ok := result.(*ast.Feature); !ok {
			return fmt.Errorf("Expected to decode a Feature but it was not")
		} else {
			intoActual.Name = resultActual.Name
			intoActual.NameRange = resultActual.NameRange
			intoActual.Value = resultActual.Value
			intoActual.ValueRange = resultActual.ValueRange
			intoActual.ValueType = resultActual.ValueType
		}
	case *ast.File:
		if resultActual, ok := result.(*ast.File); !ok {
			return fmt.Errorf("Expected to decode a File but it was not")
		} else {
			intoActual.Globals = resultActual.Globals
			intoActual.Imports = resultActual.Imports
			intoActual.Mocks = resultActual.Mocks
			intoActual.Params = resultActual.Params
			intoActual.Policies = resultActual.Policies
			intoActual.SentinelOptions = resultActual.SentinelOptions
			intoActual.Test = resultActual.Test
		}
	case *ast.Global:
		if resultActual, ok := result.(*ast.Global); !ok {
			return fmt.Errorf("Expected to decode a Global but it was not")
		} else {
			intoActual.GlobalRange = resultActual.GlobalRange
			intoActual.Name = resultActual.Name
			intoActual.NameRange = resultActual.NameRange
			intoActual.Value = resultActual.Value
			intoActual.ValueRange = resultActual.ValueRange
			intoActual.ValueType = resultActual.ValueType
		}
	case *ast.Mock:
		if resultActual, ok := result.(*ast.Mock); !ok {
			return fmt.Errorf("Expected to decode a Mock but it was not")
		} else {
			intoActual.Data = resultActual.Data
			intoActual.DataRange = resultActual.DataRange
			intoActual.MockRange = resultActual.MockRange
			intoActual.Module = resultActual.Module
			intoActual.Name = resultActual.Name
			intoActual.NameRange = resultActual.NameRange
		}
	case *ast.MockModule:
		if resultActual, ok := result.(*ast.MockModule); !ok {
			return fmt.Errorf("Expected to decode a MockModule but it was not")
		} else {
			intoActual.MockModuleRange = resultActual.MockModuleRange
			intoActual.Source = resultActual.Source
			intoActual.SourceRange = resultActual.SourceRange
		}
	case *ast.Parameter:
		if resultActual, ok := result.(*ast.Parameter); !ok {
			return fmt.Errorf("Expected to decode a Parameter but it was not")
		} else {
			intoActual.Name = resultActual.Name
			intoActual.NameRange = resultActual.NameRange
			intoActual.ParameterRange = resultActual.ParameterRange
			intoActual.Value = resultActual.Value
			intoActual.ValueRange = resultActual.ValueRange
			intoActual.ValueType = resultActual.ValueType
		}
	case *ast.Policy:
		if resultActual, ok := result.(*ast.Policy); !ok {
			return fmt.Errorf("Expected to decode a Policy but it was not")
		} else {
			intoActual.EnforcementLevel = resultActual.EnforcementLevel
			intoActual.EnforcementLevelRange = resultActual.EnforcementLevelRange
			intoActual.Name = resultActual.Name
			intoActual.NameRange = resultActual.NameRange
			intoActual.Params = resultActual.Params
			intoActual.ParamsRange = resultActual.ParamsRange
			intoActual.PolicyRange = resultActual.PolicyRange
			intoActual.Source = resultActual.Source
			intoActual.SourceRange = resultActual.SourceRange
		}
	case *ast.SentinelOptions:
		if resultActual, ok := result.(*ast.SentinelOptions); !ok {
			return fmt.Errorf("Expected to decode a SentinelOptions but it was not")
		} else {
			intoActual.Features = resultActual.Features
			intoActual.FeaturesRange = resultActual.FeaturesRange
			intoActual.SentinelOptionsRange = resultActual.SentinelOptionsRange
		}
	case *ast.Test:
		if resultActual, ok := result.(*ast.Test); !ok {
			return fmt.Errorf("Expected to decode a Test but it was not")
		} else {
			intoActual.Rules = resultActual.Rules
			intoActual.RulesRange = resultActual.RulesRange
			intoActual.TestRange = resultActual.TestRange
		}
	case *ast.TestRule:
		if resultActual, ok := result.(*ast.TestRule); !ok {
			return fmt.Errorf("Expected to decode a TestRule but it was not")
		} else {
			intoActual.Name = resultActual.Name
			intoActual.NameRange = resultActual.NameRange
			intoActual.TestRuleRange = resultActual.TestRuleRange
			intoActual.ValueRange = resultActual.ValueRange
			intoActual.ValueType = resultActual.ValueType
		}
	case *ast.V1ModuleImport:
		if resultActual, ok := result.(*ast.V1ModuleImport); !ok {
			return fmt.Errorf("Expected to decode a V1ModuleImport but it was not")
		} else {
			intoActual.BlockRange = resultActual.BlockRange
			intoActual.Name = resultActual.Name
			intoActual.NameRange = resultActual.NameRange
			intoActual.Source = resultActual.Source
			intoActual.SourceRange = resultActual.SourceRange
		}
	case *ast.V1PluginImport:
		if resultActual, ok := result.(*ast.V1PluginImport); !ok {
			return fmt.Errorf("Expected to decode a V1PluginImport but it was not")
		} else {
			intoActual.Args = resultActual.Args
			intoActual.ArgsRange = resultActual.ArgsRange
			intoActual.BlockRange = resultActual.BlockRange
			intoActual.Config = resultActual.Config
			intoActual.ConfigRange = resultActual.ConfigRange
			intoActual.Env = resultActual.Env
			intoActual.EnvRange = resultActual.EnvRange
			intoActual.Name = resultActual.Name
			intoActual.NameRange = resultActual.NameRange
			intoActual.Path = resultActual.Path
			intoActual.PathRange = resultActual.PathRange
		}
	case *ast.V2ModuleImport:
		if resultActual, ok := result.(*ast.V2ModuleImport); !ok {
			return fmt.Errorf("Expected to decode a V2ModuleImport but it was not")
		} else {
			intoActual.BlockRange = resultActual.BlockRange
			intoActual.Kind = resultActual.Kind
			intoActual.KindRange = resultActual.KindRange
			intoActual.Name = resultActual.Name
			intoActual.NameRange = resultActual.NameRange
			intoActual.Source = resultActual.Source
			intoActual.SourceRange = resultActual.SourceRange
		}
	case *ast.V2PluginImport:
		if resultActual, ok := result.(*ast.V2PluginImport); !ok {
			return fmt.Errorf("Expected to decode a V2PluginImport but it was not")
		} else {
			intoActual.Args = resultActual.Args
			intoActual.ArgsRange = resultActual.ArgsRange
			intoActual.BlockRange = resultActual.BlockRange
			intoActual.Config = resultActual.Config
			intoActual.ConfigRange = resultActual.ConfigRange
			intoActual.Env = resultActual.Env
			intoActual.EnvRange = resultActual.EnvRange
			intoActual.Kind = resultActual.Kind
			intoActual.KindRange = resultActual.KindRange
			intoActual.Name = resultActual.Name
			intoActual.NameRange = resultActual.NameRange
			intoActual.Source = resultActual.Source
			intoActual.SourceRange = resultActual.SourceRange
		}
	case *ast.V2StaticImport:
		if resultActual, ok := result.(*ast.V2StaticImport); !ok {
			return fmt.Errorf("Expected to decode a V2StaticImport but it was not")
		} else {
			intoActual.BlockRange = resultActual.BlockRange
			intoActual.Format = resultActual.Format
			intoActual.FormatRange = resultActual.FormatRange
			intoActual.Kind = resultActual.Kind
			intoActual.KindRange = resultActual.KindRange
			intoActual.Name = resultActual.Name
			intoActual.NameRange = resultActual.NameRange
			intoActual.Source = resultActual.Source
			intoActual.SourceRange = resultActual.SourceRange
		}

	default:
		return fmt.Errorf("Unknown type %T while deserializing", intoActual)
	}

	return nil
}

func (jc *jsonCoder) readFeature(data rawJsonObject) (*ast.Feature, error) {
	jc.tracer.PushMethod("readFeature", "")
	defer jc.tracer.PopMethod("readFeature")

	if data.AstType != "Feature" {
		return nil, fmt.Errorf("expected '_t' property in 'Feature' object to be 'Feature' but got %q", data.AstType)
	}
	obj := ast.Feature{}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'Feature' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NameRange
	jc.tracer.Trace("Reading NameRange")
	if raw, err := data.readPropertyBytes("namerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NameRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if raw, err := data.readProperty("value"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Value, err = jc.readDynamicValue(*raw); err != nil {
			return nil, err
		}
	}

	// ValueRange
	jc.tracer.Trace("Reading ValueRange")
	if raw, err := data.readPropertyBytes("valuerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ValueRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// ValueType
	jc.tracer.Trace("Reading ValueType")
	if val, err := readValue[string](data.Properties["valuetype"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'valuetype' property in 'Feature' object: %s", err)
	} else {
		obj.ValueType = *val
	}

	return &obj, nil
}

func (jc *jsonCoder) readFile(data rawJsonObject) (*ast.File, error) {
	jc.tracer.PushMethod("readFile", "")
	defer jc.tracer.PopMethod("readFile")

	if data.AstType != "File" {
		return nil, fmt.Errorf("expected '_t' property in 'File' object to be 'File' but got %q", data.AstType)
	}
	obj := ast.File{}

	// Globals
	jc.tracer.Trace("Reading Globals")
	if raw, err := data.readPropertyBytes("globals"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueStringMapPointer[ast.Global](*raw, jc.readGlobal); err != nil {
			return nil, err
		} else {
			obj.Globals = *val
		}
	}

	// Imports
	jc.tracer.Trace("Reading Imports")
	if raw, err := data.readPropertyBytes("imports"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueStringMap[ast.Import](*raw, jc.readImport); err != nil {
			return nil, err
		} else {
			obj.Imports = *val
		}
	}

	// Mocks
	jc.tracer.Trace("Reading Mocks")
	if raw, err := data.readPropertyBytes("mocks"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueStringMapPointer[ast.Mock](*raw, jc.readMock); err != nil {
			return nil, err
		} else {
			obj.Mocks = *val
		}
	}

	// Params
	jc.tracer.Trace("Reading Params")
	if raw, err := data.readPropertyBytes("params"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueStringMapPointer[ast.Parameter](*raw, jc.readParameter); err != nil {
			return nil, err
		} else {
			obj.Params = *val
		}
	}

	// Policies
	jc.tracer.Trace("Reading Policies")
	if raw, err := data.readPropertyBytes("policies"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueStringMapPointer[ast.Policy](*raw, jc.readPolicy); err != nil {
			return nil, err
		} else {
			obj.Policies = *val
		}
	}

	// SentinelOptions
	jc.tracer.Trace("Reading SentinelOptions")
	if raw, err := data.readProperty("sentineloptions"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.SentinelOptions, err = jc.readSentinelOptions(*raw); err != nil {
			return nil, err
		}
	}

	// Test
	jc.tracer.Trace("Reading Test")
	if raw, err := data.readProperty("test"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Test, err = jc.readTest(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readGlobal(data rawJsonObject) (*ast.Global, error) {
	jc.tracer.PushMethod("readGlobal", "")
	defer jc.tracer.PopMethod("readGlobal")

	if data.AstType != "Global" {
		return nil, fmt.Errorf("expected '_t' property in 'Global' object to be 'Global' but got %q", data.AstType)
	}
	obj := ast.Global{}

	// GlobalRange
	jc.tracer.Trace("Reading GlobalRange")
	if raw, err := data.readPropertyBytes("globalrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.GlobalRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'Global' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NameRange
	jc.tracer.Trace("Reading NameRange")
	if raw, err := data.readPropertyBytes("namerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NameRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if raw, err := data.readProperty("value"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Value, err = jc.readDynamicValue(*raw); err != nil {
			return nil, err
		}
	}

	// ValueRange
	jc.tracer.Trace("Reading ValueRange")
	if raw, err := data.readPropertyBytes("valuerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ValueRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// ValueType
	jc.tracer.Trace("Reading ValueType")
	if val, err := readValue[string](data.Properties["valuetype"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'valuetype' property in 'Global' object: %s", err)
	} else {
		obj.ValueType = *val
	}

	return &obj, nil
}

func (jc *jsonCoder) readMock(data rawJsonObject) (*ast.Mock, error) {
	jc.tracer.PushMethod("readMock", "")
	defer jc.tracer.PopMethod("readMock")

	if data.AstType != "Mock" {
		return nil, fmt.Errorf("expected '_t' property in 'Mock' object to be 'Mock' but got %q", data.AstType)
	}
	obj := ast.Mock{}

	// Data
	jc.tracer.Trace("Reading Data")
	if raw, err := data.readPropertyBytes("data"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueStringMapPointer[ast.Parameter](*raw, jc.readParameter); err != nil {
			return nil, err
		} else {
			obj.Data = *val
		}
	}

	// DataRange
	jc.tracer.Trace("Reading DataRange")
	if raw, err := data.readPropertyBytes("datarange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.DataRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// MockRange
	jc.tracer.Trace("Reading MockRange")
	if raw, err := data.readPropertyBytes("mockrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.MockRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Module
	jc.tracer.Trace("Reading Module")
	if raw, err := data.readProperty("module"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Module, err = jc.readMockModule(*raw); err != nil {
			return nil, err
		}
	}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'Mock' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NameRange
	jc.tracer.Trace("Reading NameRange")
	if raw, err := data.readPropertyBytes("namerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NameRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readMockModule(data rawJsonObject) (*ast.MockModule, error) {
	jc.tracer.PushMethod("readMockModule", "")
	defer jc.tracer.PopMethod("readMockModule")

	if data.AstType != "MockModule" {
		return nil, fmt.Errorf("expected '_t' property in 'MockModule' object to be 'MockModule' but got %q", data.AstType)
	}
	obj := ast.MockModule{}

	// MockModuleRange
	jc.tracer.Trace("Reading MockModuleRange")
	if raw, err := data.readPropertyBytes("mockmodulerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.MockModuleRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Source
	jc.tracer.Trace("Reading Source")
	if val, err := readValue[string](data.Properties["source"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'source' property in 'MockModule' object: %s", err)
	} else {
		obj.Source = *val
	}

	// SourceRange
	jc.tracer.Trace("Reading SourceRange")
	if raw, err := data.readPropertyBytes("sourcerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.SourceRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readParameter(data rawJsonObject) (*ast.Parameter, error) {
	jc.tracer.PushMethod("readParameter", "")
	defer jc.tracer.PopMethod("readParameter")

	if data.AstType != "Parameter" {
		return nil, fmt.Errorf("expected '_t' property in 'Parameter' object to be 'Parameter' but got %q", data.AstType)
	}
	obj := ast.Parameter{}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'Parameter' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NameRange
	jc.tracer.Trace("Reading NameRange")
	if raw, err := data.readPropertyBytes("namerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NameRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// ParameterRange
	jc.tracer.Trace("Reading ParameterRange")
	if raw, err := data.readPropertyBytes("parameterrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ParameterRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if raw, err := data.readProperty("value"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Value, err = jc.readDynamicValue(*raw); err != nil {
			return nil, err
		}
	}

	// ValueRange
	jc.tracer.Trace("Reading ValueRange")
	if raw, err := data.readPropertyBytes("valuerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ValueRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// ValueType
	jc.tracer.Trace("Reading ValueType")
	if val, err := readValue[string](data.Properties["valuetype"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'valuetype' property in 'Parameter' object: %s", err)
	} else {
		obj.ValueType = *val
	}

	return &obj, nil
}

func (jc *jsonCoder) readPolicy(data rawJsonObject) (*ast.Policy, error) {
	jc.tracer.PushMethod("readPolicy", "")
	defer jc.tracer.PopMethod("readPolicy")

	if data.AstType != "Policy" {
		return nil, fmt.Errorf("expected '_t' property in 'Policy' object to be 'Policy' but got %q", data.AstType)
	}
	obj := ast.Policy{}

	// EnforcementLevel
	jc.tracer.Trace("Reading EnforcementLevel")
	if val, err := readValue[string](data.Properties["enforcementlevel"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'enforcementlevel' property in 'Policy' object: %s", err)
	} else {
		obj.EnforcementLevel = *val
	}

	// EnforcementLevelRange
	jc.tracer.Trace("Reading EnforcementLevelRange")
	if raw, err := data.readPropertyBytes("enforcementlevelrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.EnforcementLevelRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'Policy' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NameRange
	jc.tracer.Trace("Reading NameRange")
	if raw, err := data.readPropertyBytes("namerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NameRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Params
	jc.tracer.Trace("Reading Params")
	if raw, err := data.readPropertyBytes("params"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueStringMapPointer[ast.Parameter](*raw, jc.readParameter); err != nil {
			return nil, err
		} else {
			obj.Params = *val
		}
	}

	// ParamsRange
	jc.tracer.Trace("Reading ParamsRange")
	if raw, err := data.readPropertyBytes("paramsrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ParamsRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// PolicyRange
	jc.tracer.Trace("Reading PolicyRange")
	if raw, err := data.readPropertyBytes("policyrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.PolicyRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Source
	jc.tracer.Trace("Reading Source")
	if val, err := readValue[string](data.Properties["source"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'source' property in 'Policy' object: %s", err)
	} else {
		obj.Source = *val
	}

	// SourceRange
	jc.tracer.Trace("Reading SourceRange")
	if raw, err := data.readPropertyBytes("sourcerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.SourceRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readSentinelOptions(data rawJsonObject) (*ast.SentinelOptions, error) {
	jc.tracer.PushMethod("readSentinelOptions", "")
	defer jc.tracer.PopMethod("readSentinelOptions")

	if data.AstType != "SentinelOptions" {
		return nil, fmt.Errorf("expected '_t' property in 'SentinelOptions' object to be 'SentinelOptions' but got %q", data.AstType)
	}
	obj := ast.SentinelOptions{}

	// Features
	jc.tracer.Trace("Reading Features")
	if raw, err := data.readPropertyBytes("features"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueList[ast.Feature](*raw, jc.readFeature); err != nil {
			return nil, err
		} else {
			obj.Features = *val
		}
	}

	// FeaturesRange
	jc.tracer.Trace("Reading FeaturesRange")
	if raw, err := data.readPropertyBytes("featuresrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.FeaturesRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// SentinelOptionsRange
	jc.tracer.Trace("Reading SentinelOptionsRange")
	if raw, err := data.readPropertyBytes("sentineloptionsrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.SentinelOptionsRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readTest(data rawJsonObject) (*ast.Test, error) {
	jc.tracer.PushMethod("readTest", "")
	defer jc.tracer.PopMethod("readTest")

	if data.AstType != "Test" {
		return nil, fmt.Errorf("expected '_t' property in 'Test' object to be 'Test' but got %q", data.AstType)
	}
	obj := ast.Test{}

	// Rules
	jc.tracer.Trace("Reading Rules")
	if raw, err := data.readPropertyBytes("rules"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueList[ast.TestRule](*raw, jc.readTestRule); err != nil {
			return nil, err
		} else {
			obj.Rules = *val
		}
	}

	// RulesRange
	jc.tracer.Trace("Reading RulesRange")
	if raw, err := data.readPropertyBytes("rulesrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RulesRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// TestRange
	jc.tracer.Trace("Reading TestRange")
	if raw, err := data.readPropertyBytes("testrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.TestRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readTestRule(data rawJsonObject) (*ast.TestRule, error) {
	jc.tracer.PushMethod("readTestRule", "")
	defer jc.tracer.PopMethod("readTestRule")

	if data.AstType != "TestRule" {
		return nil, fmt.Errorf("expected '_t' property in 'TestRule' object to be 'TestRule' but got %q", data.AstType)
	}
	obj := ast.TestRule{}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'TestRule' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NameRange
	jc.tracer.Trace("Reading NameRange")
	if raw, err := data.readPropertyBytes("namerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NameRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// TestRuleRange
	jc.tracer.Trace("Reading TestRuleRange")
	if raw, err := data.readPropertyBytes("testrulerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.TestRuleRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// ValueRange
	jc.tracer.Trace("Reading ValueRange")
	if raw, err := data.readPropertyBytes("valuerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ValueRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// ValueType
	jc.tracer.Trace("Reading ValueType")
	if val, err := readValue[string](data.Properties["valuetype"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'valuetype' property in 'TestRule' object: %s", err)
	} else {
		obj.ValueType = *val
	}

	return &obj, nil
}

func (jc *jsonCoder) readV1ModuleImport(data rawJsonObject) (*ast.V1ModuleImport, error) {
	jc.tracer.PushMethod("readV1ModuleImport", "")
	defer jc.tracer.PopMethod("readV1ModuleImport")

	if data.AstType != "V1ModuleImport" {
		return nil, fmt.Errorf("expected '_t' property in 'V1ModuleImport' object to be 'V1ModuleImport' but got %q", data.AstType)
	}
	obj := ast.V1ModuleImport{}

	// BlockRange
	jc.tracer.Trace("Reading BlockRange")
	if raw, err := data.readPropertyBytes("blockrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.BlockRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'V1ModuleImport' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NameRange
	jc.tracer.Trace("Reading NameRange")
	if raw, err := data.readPropertyBytes("namerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NameRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Source
	jc.tracer.Trace("Reading Source")
	if val, err := readValue[string](data.Properties["source"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'source' property in 'V1ModuleImport' object: %s", err)
	} else {
		obj.Source = *val
	}

	// SourceRange
	jc.tracer.Trace("Reading SourceRange")
	if raw, err := data.readPropertyBytes("sourcerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.SourceRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readV1PluginImport(data rawJsonObject) (*ast.V1PluginImport, error) {
	jc.tracer.PushMethod("readV1PluginImport", "")
	defer jc.tracer.PopMethod("readV1PluginImport")

	if data.AstType != "V1PluginImport" {
		return nil, fmt.Errorf("expected '_t' property in 'V1PluginImport' object to be 'V1PluginImport' but got %q", data.AstType)
	}
	obj := ast.V1PluginImport{}

	// Args
	jc.tracer.Trace("Reading Args")
	if val, err := readValue[[]string](data.Properties["args"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'args' property in 'V1PluginImport' object: %s", err)
	} else {
		obj.Args = *val
	}

	// ArgsRange
	jc.tracer.Trace("Reading ArgsRange")
	if raw, err := data.readPropertyBytes("argsrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ArgsRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// BlockRange
	jc.tracer.Trace("Reading BlockRange")
	if raw, err := data.readPropertyBytes("blockrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.BlockRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Config
	jc.tracer.Trace("Reading Config")
	if raw, err := data.readPropertyBytes("config"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueStringMapPointer[ast.Parameter](*raw, jc.readParameter); err != nil {
			return nil, err
		} else {
			obj.Config = *val
		}
	}

	// ConfigRange
	jc.tracer.Trace("Reading ConfigRange")
	if raw, err := data.readPropertyBytes("configrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ConfigRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Env
	jc.tracer.Trace("Reading Env")
	if val, err := readValue[[]string](data.Properties["env"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'env' property in 'V1PluginImport' object: %s", err)
	} else {
		obj.Env = *val
	}

	// EnvRange
	jc.tracer.Trace("Reading EnvRange")
	if raw, err := data.readPropertyBytes("envrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.EnvRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'V1PluginImport' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NameRange
	jc.tracer.Trace("Reading NameRange")
	if raw, err := data.readPropertyBytes("namerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NameRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Path
	jc.tracer.Trace("Reading Path")
	if val, err := readValue[string](data.Properties["path"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'path' property in 'V1PluginImport' object: %s", err)
	} else {
		obj.Path = *val
	}

	// PathRange
	jc.tracer.Trace("Reading PathRange")
	if raw, err := data.readPropertyBytes("pathrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.PathRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readV2ModuleImport(data rawJsonObject) (*ast.V2ModuleImport, error) {
	jc.tracer.PushMethod("readV2ModuleImport", "")
	defer jc.tracer.PopMethod("readV2ModuleImport")

	if data.AstType != "V2ModuleImport" {
		return nil, fmt.Errorf("expected '_t' property in 'V2ModuleImport' object to be 'V2ModuleImport' but got %q", data.AstType)
	}
	obj := ast.V2ModuleImport{}

	// BlockRange
	jc.tracer.Trace("Reading BlockRange")
	if raw, err := data.readPropertyBytes("blockrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.BlockRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Kind
	jc.tracer.Trace("Reading Kind")
	if val, err := readValue[string](data.Properties["kind"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'kind' property in 'V2ModuleImport' object: %s", err)
	} else {
		obj.Kind = *val
	}

	// KindRange
	jc.tracer.Trace("Reading KindRange")
	if raw, err := data.readPropertyBytes("kindrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.KindRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'V2ModuleImport' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NameRange
	jc.tracer.Trace("Reading NameRange")
	if raw, err := data.readPropertyBytes("namerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NameRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Source
	jc.tracer.Trace("Reading Source")
	if val, err := readValue[string](data.Properties["source"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'source' property in 'V2ModuleImport' object: %s", err)
	} else {
		obj.Source = *val
	}

	// SourceRange
	jc.tracer.Trace("Reading SourceRange")
	if raw, err := data.readPropertyBytes("sourcerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.SourceRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readV2PluginImport(data rawJsonObject) (*ast.V2PluginImport, error) {
	jc.tracer.PushMethod("readV2PluginImport", "")
	defer jc.tracer.PopMethod("readV2PluginImport")

	if data.AstType != "V2PluginImport" {
		return nil, fmt.Errorf("expected '_t' property in 'V2PluginImport' object to be 'V2PluginImport' but got %q", data.AstType)
	}
	obj := ast.V2PluginImport{}

	// Args
	jc.tracer.Trace("Reading Args")
	if val, err := readValue[[]string](data.Properties["args"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'args' property in 'V2PluginImport' object: %s", err)
	} else {
		obj.Args = *val
	}

	// ArgsRange
	jc.tracer.Trace("Reading ArgsRange")
	if raw, err := data.readPropertyBytes("argsrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ArgsRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// BlockRange
	jc.tracer.Trace("Reading BlockRange")
	if raw, err := data.readPropertyBytes("blockrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.BlockRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Config
	jc.tracer.Trace("Reading Config")
	if raw, err := data.readPropertyBytes("config"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueStringMapPointer[ast.Parameter](*raw, jc.readParameter); err != nil {
			return nil, err
		} else {
			obj.Config = *val
		}
	}

	// ConfigRange
	jc.tracer.Trace("Reading ConfigRange")
	if raw, err := data.readPropertyBytes("configrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ConfigRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Env
	jc.tracer.Trace("Reading Env")
	if raw, err := data.readPropertyBytes("env"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueStringMapPointer[ast.Parameter](*raw, jc.readParameter); err != nil {
			return nil, err
		} else {
			obj.Env = *val
		}
	}

	// EnvRange
	jc.tracer.Trace("Reading EnvRange")
	if raw, err := data.readPropertyBytes("envrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.EnvRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Kind
	jc.tracer.Trace("Reading Kind")
	if val, err := readValue[string](data.Properties["kind"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'kind' property in 'V2PluginImport' object: %s", err)
	} else {
		obj.Kind = *val
	}

	// KindRange
	jc.tracer.Trace("Reading KindRange")
	if raw, err := data.readPropertyBytes("kindrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.KindRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'V2PluginImport' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NameRange
	jc.tracer.Trace("Reading NameRange")
	if raw, err := data.readPropertyBytes("namerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NameRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Source
	jc.tracer.Trace("Reading Source")
	if val, err := readValue[string](data.Properties["source"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'source' property in 'V2PluginImport' object: %s", err)
	} else {
		obj.Source = *val
	}

	// SourceRange
	jc.tracer.Trace("Reading SourceRange")
	if raw, err := data.readPropertyBytes("sourcerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.SourceRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readV2StaticImport(data rawJsonObject) (*ast.V2StaticImport, error) {
	jc.tracer.PushMethod("readV2StaticImport", "")
	defer jc.tracer.PopMethod("readV2StaticImport")

	if data.AstType != "V2StaticImport" {
		return nil, fmt.Errorf("expected '_t' property in 'V2StaticImport' object to be 'V2StaticImport' but got %q", data.AstType)
	}
	obj := ast.V2StaticImport{}

	// BlockRange
	jc.tracer.Trace("Reading BlockRange")
	if raw, err := data.readPropertyBytes("blockrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.BlockRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Format
	jc.tracer.Trace("Reading Format")
	if val, err := readValue[string](data.Properties["format"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'format' property in 'V2StaticImport' object: %s", err)
	} else {
		obj.Format = *val
	}

	// FormatRange
	jc.tracer.Trace("Reading FormatRange")
	if raw, err := data.readPropertyBytes("formatrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.FormatRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Kind
	jc.tracer.Trace("Reading Kind")
	if val, err := readValue[string](data.Properties["kind"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'kind' property in 'V2StaticImport' object: %s", err)
	} else {
		obj.Kind = *val
	}

	// KindRange
	jc.tracer.Trace("Reading KindRange")
	if raw, err := data.readPropertyBytes("kindrange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.KindRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'V2StaticImport' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NameRange
	jc.tracer.Trace("Reading NameRange")
	if raw, err := data.readPropertyBytes("namerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NameRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Source
	jc.tracer.Trace("Reading Source")
	if val, err := readValue[string](data.Properties["source"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'source' property in 'V2StaticImport' object: %s", err)
	} else {
		obj.Source = *val
	}

	// SourceRange
	jc.tracer.Trace("Reading SourceRange")
	if raw, err := data.readPropertyBytes("sourcerange"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.SourceRange, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readImport(data rawJsonObject) (ast.Import, error) {
	switch data.AstType {
	case "V1ModuleImport":
		return jc.readV1ModuleImport(data)
	case "V1PluginImport":
		return jc.readV1PluginImport(data)
	case "V2ModuleImport":
		return jc.readV2ModuleImport(data)
	case "V2PluginImport":
		return jc.readV2PluginImport(data)
	case "V2StaticImport":
		return jc.readV2StaticImport(data)

	default:
		return nil, fmt.Errorf("Unknown type import %q while deserializing", data.AstType)
	}
}
