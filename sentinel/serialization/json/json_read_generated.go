package json

// Autogenerated using generate_sentinel_json.js
// DO NOT MODIFY MANUALLY
//
// This is not most effecient or quickest way to deserialize from JSON
// to an AST, but it works!

import (
	"encoding/json"
	"fmt"

	"github.com/glennsarti/sentinel-parser/sentinel/ast"
	"github.com/glennsarti/sentinel-parser/sentinel/token"
)

type rawJsonObject struct {
	AstType    string                     `json:"_t"`
	Properties map[string]json.RawMessage `json:"_p"`
}

func (jc *jsonCoder) read(data []byte) (ast.Node, error) {
	raw := rawJsonObject{}
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	switch raw.AstType {
	case "AssignStatement":
		return jc.readAssignStatement(raw)
	case "BadExpression":
		return jc.readBadExpression(raw)
	case "BadStatement":
		return jc.readBadStatement(raw)
	case "BasicLit":
		return jc.readBasicLit(raw)
	case "BinaryExpression":
		return jc.readBinaryExpression(raw)
	case "BlockStatement":
		return jc.readBlockStatement(raw)
	case "BranchStatement":
		return jc.readBranchStatement(raw)
	case "CallExpression":
		return jc.readCallExpression(raw)
	case "CaseWhenClause":
		return jc.readCaseWhenClause(raw)
	case "CaseStatement":
		return jc.readCaseStatement(raw)
	case "Comment":
		return jc.readComment(raw)
	case "Comments":
		return jc.readComments(raw)
	case "EmptyStatement":
		return jc.readEmptyStatement(raw)
	case "ExpressionStatement":
		return jc.readExpressionStatement(raw)
	case "FieldList":
		return jc.readFieldList(raw)
	case "File":
		return jc.readFile(raw)
	case "FuncDecl":
		return jc.readFuncDecl(raw)
	case "FuncLit":
		return jc.readFuncLit(raw)
	case "Ident":
		return jc.readIdent(raw)
	case "IfStatement":
		return jc.readIfStatement(raw)
	case "ImportDecl":
		return jc.readImportDecl(raw)
	case "IndexExpression":
		return jc.readIndexExpression(raw)
	case "ForStatement":
		return jc.readForStatement(raw)
	case "GroupExpression":
		return jc.readGroupExpression(raw)
	case "KeyedElementExpression":
		return jc.readKeyedElementExpression(raw)
	case "ListLit":
		return jc.readListLit(raw)
	case "MapLit":
		return jc.readMapLit(raw)
	case "ParamDecl":
		return jc.readParamDecl(raw)
	case "QuantExpression":
		return jc.readQuantExpression(raw)
	case "ReturnStatement":
		return jc.readReturnStatement(raw)
	case "RuleExpression":
		return jc.readRuleExpression(raw)
	case "SelectorExpression":
		return jc.readSelectorExpression(raw)
	case "SliceExpression":
		return jc.readSliceExpression(raw)
	case "UnaryExpression":
		return jc.readUnaryExpression(raw)

	default:
		return nil, fmt.Errorf("Unknown type %q while deserializing", raw.AstType)
	}
}

func (jc *jsonCoder) readInto(data []byte, into ast.Node) error {
	result, err := jc.read(data)
	if err != nil {
		return err
	}

	switch intoActual := into.(type) {
	case *ast.AssignStatement:
		if resultActual, ok := result.(*ast.AssignStatement); !ok {
			return fmt.Errorf("Expected to decode a AssignStatement but it was not")
		} else {
			intoActual.AssignOp = resultActual.AssignOp
			intoActual.AssignOpPos = resultActual.AssignOpPos
			intoActual.LhsExpr = resultActual.LhsExpr
			intoActual.NodePos = resultActual.NodePos
			intoActual.RhsExpr = resultActual.RhsExpr
		}
	case *ast.BadExpression:
		if resultActual, ok := result.(*ast.BadExpression); !ok {
			return fmt.Errorf("Expected to decode a BadExpression but it was not")
		} else {
			intoActual.NodePos = resultActual.NodePos
		}
	case *ast.BadStatement:
		if resultActual, ok := result.(*ast.BadStatement); !ok {
			return fmt.Errorf("Expected to decode a BadStatement but it was not")
		} else {
			intoActual.NodePos = resultActual.NodePos
		}
	case *ast.BasicLit:
		if resultActual, ok := result.(*ast.BasicLit); !ok {
			return fmt.Errorf("Expected to decode a BasicLit but it was not")
		} else {
			intoActual.Kind = resultActual.Kind
			intoActual.NodePos = resultActual.NodePos
			intoActual.Value = resultActual.Value
		}
	case *ast.BinaryExpression:
		if resultActual, ok := result.(*ast.BinaryExpression); !ok {
			return fmt.Errorf("Expected to decode a BinaryExpression but it was not")
		} else {
			intoActual.LeftExpr = resultActual.LeftExpr
			intoActual.NodePos = resultActual.NodePos
			intoActual.Op = resultActual.Op
			intoActual.OpPos = resultActual.OpPos
			intoActual.RightExpr = resultActual.RightExpr
		}
	case *ast.BlockStatement:
		if resultActual, ok := result.(*ast.BlockStatement); !ok {
			return fmt.Errorf("Expected to decode a BlockStatement but it was not")
		} else {
			intoActual.LeftBrace = resultActual.LeftBrace
			intoActual.NodePos = resultActual.NodePos
			intoActual.RightBrace = resultActual.RightBrace
			intoActual.Statments = resultActual.Statments
		}
	case *ast.BranchStatement:
		if resultActual, ok := result.(*ast.BranchStatement); !ok {
			return fmt.Errorf("Expected to decode a BranchStatement but it was not")
		} else {
			intoActual.Kind = resultActual.Kind
			intoActual.NodePos = resultActual.NodePos
		}
	case *ast.CallExpression:
		if resultActual, ok := result.(*ast.CallExpression); !ok {
			return fmt.Errorf("Expected to decode a CallExpression but it was not")
		} else {
			intoActual.Args = resultActual.Args
			intoActual.Callee = resultActual.Callee
			intoActual.LeftParen = resultActual.LeftParen
			intoActual.NodePos = resultActual.NodePos
			intoActual.RightParen = resultActual.RightParen
		}
	case *ast.CaseWhenClause:
		if resultActual, ok := result.(*ast.CaseWhenClause); !ok {
			return fmt.Errorf("Expected to decode a CaseWhenClause but it was not")
		} else {
			intoActual.ColonPos = resultActual.ColonPos
			intoActual.Conditions = resultActual.Conditions
			intoActual.NodePos = resultActual.NodePos
			intoActual.Statements = resultActual.Statements
			intoActual.TokenKind = resultActual.TokenKind
			intoActual.TokenPos = resultActual.TokenPos
		}
	case *ast.CaseStatement:
		if resultActual, ok := result.(*ast.CaseStatement); !ok {
			return fmt.Errorf("Expected to decode a CaseStatement but it was not")
		} else {
			intoActual.CasePos = resultActual.CasePos
			intoActual.Clauses = resultActual.Clauses
			intoActual.NodePos = resultActual.NodePos
			intoActual.Value = resultActual.Value
		}
	case *ast.Comment:
		if resultActual, ok := result.(*ast.Comment); !ok {
			return fmt.Errorf("Expected to decode a Comment but it was not")
		} else {
			intoActual.NodePos = resultActual.NodePos
			intoActual.Prefix = resultActual.Prefix
			intoActual.PrefixPos = resultActual.PrefixPos
			intoActual.Text = resultActual.Text
			intoActual.TextPos = resultActual.TextPos
		}
	case *ast.Comments:
		if resultActual, ok := result.(*ast.Comments); !ok {
			return fmt.Errorf("Expected to decode a Comments but it was not")
		} else {
			intoActual.List = resultActual.List
			intoActual.NodePos = resultActual.NodePos
		}
	case *ast.EmptyStatement:
		if resultActual, ok := result.(*ast.EmptyStatement); !ok {
			return fmt.Errorf("Expected to decode a EmptyStatement but it was not")
		} else {
			intoActual.Implied = resultActual.Implied
			intoActual.NodePos = resultActual.NodePos
		}
	case *ast.ExpressionStatement:
		if resultActual, ok := result.(*ast.ExpressionStatement); !ok {
			return fmt.Errorf("Expected to decode a ExpressionStatement but it was not")
		} else {
			intoActual.Expr = resultActual.Expr
			intoActual.NodePos = resultActual.NodePos
		}
	case *ast.FieldList:
		if resultActual, ok := result.(*ast.FieldList); !ok {
			return fmt.Errorf("Expected to decode a FieldList but it was not")
		} else {
			intoActual.Fields = resultActual.Fields
			intoActual.LeftParen = resultActual.LeftParen
			intoActual.NodePos = resultActual.NodePos
			intoActual.RightParen = resultActual.RightParen
		}
	case *ast.File:
		if resultActual, ok := result.(*ast.File); !ok {
			return fmt.Errorf("Expected to decode a File but it was not")
		} else {
			intoActual.Doc = resultActual.Doc
			intoActual.Imports = resultActual.Imports
			intoActual.NodePos = resultActual.NodePos
			intoActual.Params = resultActual.Params
			intoActual.Statements = resultActual.Statements
		}
	case *ast.FuncDecl:
		if resultActual, ok := result.(*ast.FuncDecl); !ok {
			return fmt.Errorf("Expected to decode a FuncDecl but it was not")
		} else {
			intoActual.Body = resultActual.Body
			intoActual.Doc = resultActual.Doc
			intoActual.FuncPos = resultActual.FuncPos
			intoActual.Name = resultActual.Name
			intoActual.NodePos = resultActual.NodePos
			intoActual.Params = resultActual.Params
		}
	case *ast.FuncLit:
		if resultActual, ok := result.(*ast.FuncLit); !ok {
			return fmt.Errorf("Expected to decode a FuncLit but it was not")
		} else {
			intoActual.Body = resultActual.Body
			intoActual.FuncPos = resultActual.FuncPos
			intoActual.NodePos = resultActual.NodePos
			intoActual.Params = resultActual.Params
		}
	case *ast.Ident:
		if resultActual, ok := result.(*ast.Ident); !ok {
			return fmt.Errorf("Expected to decode a Ident but it was not")
		} else {
			intoActual.Name = resultActual.Name
			intoActual.NodePos = resultActual.NodePos
		}
	case *ast.IfStatement:
		if resultActual, ok := result.(*ast.IfStatement); !ok {
			return fmt.Errorf("Expected to decode a IfStatement but it was not")
		} else {
			intoActual.Condition = resultActual.Condition
			intoActual.ElsePos = resultActual.ElsePos
			intoActual.FalseBlock = resultActual.FalseBlock
			intoActual.IfPos = resultActual.IfPos
			intoActual.NodePos = resultActual.NodePos
			intoActual.TrueBlock = resultActual.TrueBlock
		}
	case *ast.ImportDecl:
		if resultActual, ok := result.(*ast.ImportDecl); !ok {
			return fmt.Errorf("Expected to decode a ImportDecl but it was not")
		} else {
			intoActual.Alias = resultActual.Alias
			intoActual.AsPos = resultActual.AsPos
			intoActual.Doc = resultActual.Doc
			intoActual.ImportPos = resultActual.ImportPos
			intoActual.Name = resultActual.Name
			intoActual.NodePos = resultActual.NodePos
		}
	case *ast.IndexExpression:
		if resultActual, ok := result.(*ast.IndexExpression); !ok {
			return fmt.Errorf("Expected to decode a IndexExpression but it was not")
		} else {
			intoActual.Index = resultActual.Index
			intoActual.LeftBrack = resultActual.LeftBrack
			intoActual.NodePos = resultActual.NodePos
			intoActual.RightBrack = resultActual.RightBrack
			intoActual.Value = resultActual.Value
		}
	case *ast.ForStatement:
		if resultActual, ok := result.(*ast.ForStatement); !ok {
			return fmt.Errorf("Expected to decode a ForStatement but it was not")
		} else {
			intoActual.AsPos = resultActual.AsPos
			intoActual.Block = resultActual.Block
			intoActual.ForPos = resultActual.ForPos
			intoActual.Iterable = resultActual.Iterable
			intoActual.Iterator1 = resultActual.Iterator1
			intoActual.Iterator2 = resultActual.Iterator2
			intoActual.NodePos = resultActual.NodePos
		}
	case *ast.GroupExpression:
		if resultActual, ok := result.(*ast.GroupExpression); !ok {
			return fmt.Errorf("Expected to decode a GroupExpression but it was not")
		} else {
			intoActual.LeftParen = resultActual.LeftParen
			intoActual.NodePos = resultActual.NodePos
			intoActual.RightParen = resultActual.RightParen
			intoActual.Value = resultActual.Value
		}
	case *ast.KeyedElementExpression:
		if resultActual, ok := result.(*ast.KeyedElementExpression); !ok {
			return fmt.Errorf("Expected to decode a KeyedElementExpression but it was not")
		} else {
			intoActual.ColonPos = resultActual.ColonPos
			intoActual.Key = resultActual.Key
			intoActual.NodePos = resultActual.NodePos
			intoActual.Value = resultActual.Value
		}
	case *ast.ListLit:
		if resultActual, ok := result.(*ast.ListLit); !ok {
			return fmt.Errorf("Expected to decode a ListLit but it was not")
		} else {
			intoActual.Items = resultActual.Items
			intoActual.LeftBrack = resultActual.LeftBrack
			intoActual.NodePos = resultActual.NodePos
			intoActual.RightBrack = resultActual.RightBrack
		}
	case *ast.MapLit:
		if resultActual, ok := result.(*ast.MapLit); !ok {
			return fmt.Errorf("Expected to decode a MapLit but it was not")
		} else {
			intoActual.Elements = resultActual.Elements
			intoActual.LeftBrace = resultActual.LeftBrace
			intoActual.NodePos = resultActual.NodePos
			intoActual.RightBrace = resultActual.RightBrace
		}
	case *ast.ParamDecl:
		if resultActual, ok := result.(*ast.ParamDecl); !ok {
			return fmt.Errorf("Expected to decode a ParamDecl but it was not")
		} else {
			intoActual.Default = resultActual.Default
			intoActual.DefaultPos = resultActual.DefaultPos
			intoActual.Doc = resultActual.Doc
			intoActual.Name = resultActual.Name
			intoActual.NodePos = resultActual.NodePos
		}
	case *ast.QuantExpression:
		if resultActual, ok := result.(*ast.QuantExpression); !ok {
			return fmt.Errorf("Expected to decode a QuantExpression but it was not")
		} else {
			intoActual.AsPos = resultActual.AsPos
			intoActual.CommaPos = resultActual.CommaPos
			intoActual.LeftBrace = resultActual.LeftBrace
			intoActual.Name1 = resultActual.Name1
			intoActual.Name2 = resultActual.Name2
			intoActual.NodePos = resultActual.NodePos
			intoActual.Op = resultActual.Op
			intoActual.OpPos = resultActual.OpPos
			intoActual.Quantifier = resultActual.Quantifier
			intoActual.RightBrace = resultActual.RightBrace
			intoActual.Value = resultActual.Value
		}
	case *ast.ReturnStatement:
		if resultActual, ok := result.(*ast.ReturnStatement); !ok {
			return fmt.Errorf("Expected to decode a ReturnStatement but it was not")
		} else {
			intoActual.NodePos = resultActual.NodePos
			intoActual.Result = resultActual.Result
			intoActual.ReturnPos = resultActual.ReturnPos
		}
	case *ast.RuleExpression:
		if resultActual, ok := result.(*ast.RuleExpression); !ok {
			return fmt.Errorf("Expected to decode a RuleExpression but it was not")
		} else {
			intoActual.Doc = resultActual.Doc
			intoActual.LeftBracePos = resultActual.LeftBracePos
			intoActual.NodePos = resultActual.NodePos
			intoActual.RightBracePos = resultActual.RightBracePos
			intoActual.RuleTokenPos = resultActual.RuleTokenPos
			intoActual.Value = resultActual.Value
			intoActual.When = resultActual.When
			intoActual.WhenTokenPos = resultActual.WhenTokenPos
		}
	case *ast.SelectorExpression:
		if resultActual, ok := result.(*ast.SelectorExpression); !ok {
			return fmt.Errorf("Expected to decode a SelectorExpression but it was not")
		} else {
			intoActual.NodePos = resultActual.NodePos
			intoActual.Selector = resultActual.Selector
			intoActual.Value = resultActual.Value
		}
	case *ast.SliceExpression:
		if resultActual, ok := result.(*ast.SliceExpression); !ok {
			return fmt.Errorf("Expected to decode a SliceExpression but it was not")
		} else {
			intoActual.Colon = resultActual.Colon
			intoActual.HighExpr = resultActual.HighExpr
			intoActual.LeftBrack = resultActual.LeftBrack
			intoActual.LowExpr = resultActual.LowExpr
			intoActual.NodePos = resultActual.NodePos
			intoActual.RightBrack = resultActual.RightBrack
			intoActual.Value = resultActual.Value
		}
	case *ast.UnaryExpression:
		if resultActual, ok := result.(*ast.UnaryExpression); !ok {
			return fmt.Errorf("Expected to decode a UnaryExpression but it was not")
		} else {
			intoActual.NodePos = resultActual.NodePos
			intoActual.Op = resultActual.Op
			intoActual.OpPos = resultActual.OpPos
			intoActual.RhsExpr = resultActual.RhsExpr
		}

	default:
		return fmt.Errorf("Unknown type %T while deserializing", intoActual)
	}

	return nil
}


func(jc * jsonCoder) readAssignStatement(data rawJsonObject) (*ast.AssignStatement, error) {
	jc.tracer.PushMethod("readAssignStatement", "")
	defer jc.tracer.PopMethod("readAssignStatement")

	if data.AstType != "AssignStatement" {
		return nil, fmt.Errorf("expected '_t' property in 'AssignStatement' object to be 'AssignStatement' but got %q", data.AstType)
	}
	obj := ast.AssignStatement{}

	// AssignOp
	jc.tracer.Trace("Reading AssignOp")
	if val, err := readValue[token.TokenType](data.Properties["assignop"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'assignop' property in 'AssignStatement' object: %s", err)
	} else {
		obj.AssignOp = *val
	}

	// AssignOpPos
	jc.tracer.Trace("Reading AssignOpPos")
	if raw, err := data.readPropertyBytes("assignoppos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.AssignOpPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// LhsExpr
	jc.tracer.Trace("Reading LhsExpr")
	if raw, err := data.readProperty("lhsexpr"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LhsExpr, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RhsExpr
	jc.tracer.Trace("Reading RhsExpr")
	if raw, err := data.readProperty("rhsexpr"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RhsExpr, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readBadExpression(data rawJsonObject) (*ast.BadExpression, error) {
	jc.tracer.PushMethod("readBadExpression", "")
	defer jc.tracer.PopMethod("readBadExpression")

	if data.AstType != "BadExpression" {
		return nil, fmt.Errorf("expected '_t' property in 'BadExpression' object to be 'BadExpression' but got %q", data.AstType)
	}
	obj := ast.BadExpression{}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readBadStatement(data rawJsonObject) (*ast.BadStatement, error) {
	jc.tracer.PushMethod("readBadStatement", "")
	defer jc.tracer.PopMethod("readBadStatement")

	if data.AstType != "BadStatement" {
		return nil, fmt.Errorf("expected '_t' property in 'BadStatement' object to be 'BadStatement' but got %q", data.AstType)
	}
	obj := ast.BadStatement{}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readBasicLit(data rawJsonObject) (*ast.BasicLit, error) {
	jc.tracer.PushMethod("readBasicLit", "")
	defer jc.tracer.PopMethod("readBasicLit")

	if data.AstType != "BasicLit" {
		return nil, fmt.Errorf("expected '_t' property in 'BasicLit' object to be 'BasicLit' but got %q", data.AstType)
	}
	obj := ast.BasicLit{}

	// Kind
	jc.tracer.Trace("Reading Kind")
	if val, err := readValue[token.TokenType](data.Properties["kind"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'kind' property in 'BasicLit' object: %s", err)
	} else {
		obj.Kind = *val
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if val, err := readValue[string](data.Properties["value"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'value' property in 'BasicLit' object: %s", err)
	} else {
		obj.Value = *val
	}

	return &obj, nil
}

func(jc * jsonCoder) readBinaryExpression(data rawJsonObject) (*ast.BinaryExpression, error) {
	jc.tracer.PushMethod("readBinaryExpression", "")
	defer jc.tracer.PopMethod("readBinaryExpression")

	if data.AstType != "BinaryExpression" {
		return nil, fmt.Errorf("expected '_t' property in 'BinaryExpression' object to be 'BinaryExpression' but got %q", data.AstType)
	}
	obj := ast.BinaryExpression{}

	// LeftExpr
	jc.tracer.Trace("Reading LeftExpr")
	if raw, err := data.readProperty("leftexpr"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LeftExpr, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Op
	jc.tracer.Trace("Reading Op")
	if val, err := readValue[token.TokenType](data.Properties["op"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'op' property in 'BinaryExpression' object: %s", err)
	} else {
		obj.Op = *val
	}

	// OpPos
	jc.tracer.Trace("Reading OpPos")
	if raw, err := data.readPropertyBytes("oppos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.OpPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RightExpr
	jc.tracer.Trace("Reading RightExpr")
	if raw, err := data.readProperty("rightexpr"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RightExpr, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readBlockStatement(data rawJsonObject) (*ast.BlockStatement, error) {
	jc.tracer.PushMethod("readBlockStatement", "")
	defer jc.tracer.PopMethod("readBlockStatement")

	if data.AstType != "BlockStatement" {
		return nil, fmt.Errorf("expected '_t' property in 'BlockStatement' object to be 'BlockStatement' but got %q", data.AstType)
	}
	obj := ast.BlockStatement{}

	// LeftBrace
	jc.tracer.Trace("Reading LeftBrace")
	if raw, err := data.readPropertyBytes("leftbrace"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LeftBrace, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RightBrace
	jc.tracer.Trace("Reading RightBrace")
	if raw, err := data.readPropertyBytes("rightbrace"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RightBrace, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Statments
	jc.tracer.Trace("Reading Statments")
	if raw, err := data.readPropertyBytes("statments"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueList[ast.Statement](*raw, jc.readStatement); err != nil {
			return nil, err
		} else {
			obj.Statments = *val
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readBranchStatement(data rawJsonObject) (*ast.BranchStatement, error) {
	jc.tracer.PushMethod("readBranchStatement", "")
	defer jc.tracer.PopMethod("readBranchStatement")

	if data.AstType != "BranchStatement" {
		return nil, fmt.Errorf("expected '_t' property in 'BranchStatement' object to be 'BranchStatement' but got %q", data.AstType)
	}
	obj := ast.BranchStatement{}

	// Kind
	jc.tracer.Trace("Reading Kind")
	if val, err := readValue[token.TokenType](data.Properties["kind"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'kind' property in 'BranchStatement' object: %s", err)
	} else {
		obj.Kind = *val
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readCallExpression(data rawJsonObject) (*ast.CallExpression, error) {
	jc.tracer.PushMethod("readCallExpression", "")
	defer jc.tracer.PopMethod("readCallExpression")

	if data.AstType != "CallExpression" {
		return nil, fmt.Errorf("expected '_t' property in 'CallExpression' object to be 'CallExpression' but got %q", data.AstType)
	}
	obj := ast.CallExpression{}

	// Args
	jc.tracer.Trace("Reading Args")
	if raw, err := data.readPropertyBytes("args"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueList[ast.Expression](*raw, jc.readExpression); err != nil {
			return nil, err
		} else {
			obj.Args = *val
		}
	}

	// Callee
	jc.tracer.Trace("Reading Callee")
	if raw, err := data.readProperty("callee"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Callee, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// LeftParen
	jc.tracer.Trace("Reading LeftParen")
	if raw, err := data.readPropertyBytes("leftparen"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LeftParen, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RightParen
	jc.tracer.Trace("Reading RightParen")
	if raw, err := data.readPropertyBytes("rightparen"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RightParen, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readCaseWhenClause(data rawJsonObject) (*ast.CaseWhenClause, error) {
	jc.tracer.PushMethod("readCaseWhenClause", "")
	defer jc.tracer.PopMethod("readCaseWhenClause")

	if data.AstType != "CaseWhenClause" {
		return nil, fmt.Errorf("expected '_t' property in 'CaseWhenClause' object to be 'CaseWhenClause' but got %q", data.AstType)
	}
	obj := ast.CaseWhenClause{}

	// ColonPos
	jc.tracer.Trace("Reading ColonPos")
	if raw, err := data.readPropertyBytes("colonpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ColonPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Conditions
	jc.tracer.Trace("Reading Conditions")
	if raw, err := data.readPropertyBytes("conditions"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueList[ast.Expression](*raw, jc.readExpression); err != nil {
			return nil, err
		} else {
			obj.Conditions = *val
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Statements
	jc.tracer.Trace("Reading Statements")
	if raw, err := data.readPropertyBytes("statements"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueList[ast.Statement](*raw, jc.readStatement); err != nil {
			return nil, err
		} else {
			obj.Statements = *val
		}
	}

	// TokenKind
	jc.tracer.Trace("Reading TokenKind")
	if val, err := readValue[token.TokenType](data.Properties["tokenkind"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'tokenkind' property in 'CaseWhenClause' object: %s", err)
	} else {
		obj.TokenKind = *val
	}

	// TokenPos
	jc.tracer.Trace("Reading TokenPos")
	if raw, err := data.readPropertyBytes("tokenpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.TokenPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readCaseStatement(data rawJsonObject) (*ast.CaseStatement, error) {
	jc.tracer.PushMethod("readCaseStatement", "")
	defer jc.tracer.PopMethod("readCaseStatement")

	if data.AstType != "CaseStatement" {
		return nil, fmt.Errorf("expected '_t' property in 'CaseStatement' object to be 'CaseStatement' but got %q", data.AstType)
	}
	obj := ast.CaseStatement{}

	// CasePos
	jc.tracer.Trace("Reading CasePos")
	if raw, err := data.readPropertyBytes("casepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.CasePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Clauses
	jc.tracer.Trace("Reading Clauses")
	if raw, err := data.readProperty("clauses"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Clauses, err = jc.readBlockStatement(*raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if raw, err := data.readProperty("value"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Value, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readComment(data rawJsonObject) (*ast.Comment, error) {
	jc.tracer.PushMethod("readComment", "")
	defer jc.tracer.PopMethod("readComment")

	if data.AstType != "Comment" {
		return nil, fmt.Errorf("expected '_t' property in 'Comment' object to be 'Comment' but got %q", data.AstType)
	}
	obj := ast.Comment{}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Prefix
	jc.tracer.Trace("Reading Prefix")
	if val, err := readValue[string](data.Properties["prefix"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'prefix' property in 'Comment' object: %s", err)
	} else {
		obj.Prefix = *val
	}

	// PrefixPos
	jc.tracer.Trace("Reading PrefixPos")
	if raw, err := data.readPropertyBytes("prefixpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.PrefixPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Text
	jc.tracer.Trace("Reading Text")
	if val, err := readValue[string](data.Properties["text"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'text' property in 'Comment' object: %s", err)
	} else {
		obj.Text = *val
	}

	// TextPos
	jc.tracer.Trace("Reading TextPos")
	if raw, err := data.readPropertyBytes("textpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.TextPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readComments(data rawJsonObject) (*ast.Comments, error) {
	jc.tracer.PushMethod("readComments", "")
	defer jc.tracer.PopMethod("readComments")

	if data.AstType != "Comments" {
		return nil, fmt.Errorf("expected '_t' property in 'Comments' object to be 'Comments' but got %q", data.AstType)
	}
	obj := ast.Comments{}

	// List
	jc.tracer.Trace("Reading List")
	if raw, err := data.readPropertyBytes("list"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValuePtrList[ast.Comment](*raw, jc.readComment); err != nil {
			return nil, err
		} else {
			obj.List = *val
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readEmptyStatement(data rawJsonObject) (*ast.EmptyStatement, error) {
	jc.tracer.PushMethod("readEmptyStatement", "")
	defer jc.tracer.PopMethod("readEmptyStatement")

	if data.AstType != "EmptyStatement" {
		return nil, fmt.Errorf("expected '_t' property in 'EmptyStatement' object to be 'EmptyStatement' but got %q", data.AstType)
	}
	obj := ast.EmptyStatement{}

	// Implied
	jc.tracer.Trace("Reading Implied")
	if val, err := readValue[bool](data.Properties["implied"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'implied' property in 'EmptyStatement' object: %s", err)
	} else {
		obj.Implied = *val
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readExpressionStatement(data rawJsonObject) (*ast.ExpressionStatement, error) {
	jc.tracer.PushMethod("readExpressionStatement", "")
	defer jc.tracer.PopMethod("readExpressionStatement")

	if data.AstType != "ExpressionStatement" {
		return nil, fmt.Errorf("expected '_t' property in 'ExpressionStatement' object to be 'ExpressionStatement' but got %q", data.AstType)
	}
	obj := ast.ExpressionStatement{}

	// Expr
	jc.tracer.Trace("Reading Expr")
	if raw, err := data.readProperty("expr"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Expr, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readFieldList(data rawJsonObject) (*ast.FieldList, error) {
	jc.tracer.PushMethod("readFieldList", "")
	defer jc.tracer.PopMethod("readFieldList")

	if data.AstType != "FieldList" {
		return nil, fmt.Errorf("expected '_t' property in 'FieldList' object to be 'FieldList' but got %q", data.AstType)
	}
	obj := ast.FieldList{}

	// Fields
	jc.tracer.Trace("Reading Fields")
	if raw, err := data.readPropertyBytes("fields"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValuePtrList[ast.Ident](*raw, jc.readIdent); err != nil {
			return nil, err
		} else {
			obj.Fields = *val
		}
	}

	// LeftParen
	jc.tracer.Trace("Reading LeftParen")
	if raw, err := data.readPropertyBytes("leftparen"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LeftParen, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RightParen
	jc.tracer.Trace("Reading RightParen")
	if raw, err := data.readPropertyBytes("rightparen"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RightParen, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readFile(data rawJsonObject) (*ast.File, error) {
	jc.tracer.PushMethod("readFile", "")
	defer jc.tracer.PopMethod("readFile")

	if data.AstType != "File" {
		return nil, fmt.Errorf("expected '_t' property in 'File' object to be 'File' but got %q", data.AstType)
	}
	obj := ast.File{}

	// Doc
	jc.tracer.Trace("Reading Doc")
	if raw, err := data.readProperty("doc"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Doc, err = jc.readComments(*raw); err != nil {
			return nil, err
		}
	}

	// Imports
	jc.tracer.Trace("Reading Imports")
	if raw, err := data.readPropertyBytes("imports"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValuePtrList[ast.ImportDecl](*raw, jc.readImportDecl); err != nil {
			return nil, err
		} else {
			obj.Imports = *val
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Params
	jc.tracer.Trace("Reading Params")
	if raw, err := data.readPropertyBytes("params"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValuePtrList[ast.ParamDecl](*raw, jc.readParamDecl); err != nil {
			return nil, err
		} else {
			obj.Params = *val
		}
	}

	// Statements
	jc.tracer.Trace("Reading Statements")
	if raw, err := data.readPropertyBytes("statements"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueList[ast.Statement](*raw, jc.readStatement); err != nil {
			return nil, err
		} else {
			obj.Statements = *val
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readFuncDecl(data rawJsonObject) (*ast.FuncDecl, error) {
	jc.tracer.PushMethod("readFuncDecl", "")
	defer jc.tracer.PopMethod("readFuncDecl")

	if data.AstType != "FuncDecl" {
		return nil, fmt.Errorf("expected '_t' property in 'FuncDecl' object to be 'FuncDecl' but got %q", data.AstType)
	}
	obj := ast.FuncDecl{}

	// Body
	jc.tracer.Trace("Reading Body")
	if raw, err := data.readProperty("body"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Body, err = jc.readBlockStatement(*raw); err != nil {
			return nil, err
		}
	}

	// Doc
	jc.tracer.Trace("Reading Doc")
	if raw, err := data.readProperty("doc"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Doc, err = jc.readComments(*raw); err != nil {
			return nil, err
		}
	}

	// FuncPos
	jc.tracer.Trace("Reading FuncPos")
	if raw, err := data.readPropertyBytes("funcpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.FuncPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Name
	jc.tracer.Trace("Reading Name")
	if raw, err := data.readProperty("name"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Name, err = jc.readIdent(*raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Params
	jc.tracer.Trace("Reading Params")
	if raw, err := data.readProperty("params"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Params, err = jc.readFieldList(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readFuncLit(data rawJsonObject) (*ast.FuncLit, error) {
	jc.tracer.PushMethod("readFuncLit", "")
	defer jc.tracer.PopMethod("readFuncLit")

	if data.AstType != "FuncLit" {
		return nil, fmt.Errorf("expected '_t' property in 'FuncLit' object to be 'FuncLit' but got %q", data.AstType)
	}
	obj := ast.FuncLit{}

	// Body
	jc.tracer.Trace("Reading Body")
	if raw, err := data.readProperty("body"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Body, err = jc.readBlockStatement(*raw); err != nil {
			return nil, err
		}
	}

	// FuncPos
	jc.tracer.Trace("Reading FuncPos")
	if raw, err := data.readPropertyBytes("funcpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.FuncPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Params
	jc.tracer.Trace("Reading Params")
	if raw, err := data.readProperty("params"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Params, err = jc.readFieldList(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readIdent(data rawJsonObject) (*ast.Ident, error) {
	jc.tracer.PushMethod("readIdent", "")
	defer jc.tracer.PopMethod("readIdent")

	if data.AstType != "Ident" {
		return nil, fmt.Errorf("expected '_t' property in 'Ident' object to be 'Ident' but got %q", data.AstType)
	}
	obj := ast.Ident{}

	// Name
	jc.tracer.Trace("Reading Name")
	if val, err := readValue[string](data.Properties["name"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'name' property in 'Ident' object: %s", err)
	} else {
		obj.Name = *val
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readIfStatement(data rawJsonObject) (*ast.IfStatement, error) {
	jc.tracer.PushMethod("readIfStatement", "")
	defer jc.tracer.PopMethod("readIfStatement")

	if data.AstType != "IfStatement" {
		return nil, fmt.Errorf("expected '_t' property in 'IfStatement' object to be 'IfStatement' but got %q", data.AstType)
	}
	obj := ast.IfStatement{}

	// Condition
	jc.tracer.Trace("Reading Condition")
	if raw, err := data.readProperty("condition"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Condition, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// ElsePos
	jc.tracer.Trace("Reading ElsePos")
	if raw, err := data.readPropertyBytes("elsepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ElsePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// FalseBlock
	jc.tracer.Trace("Reading FalseBlock")
	if raw, err := data.readProperty("falseblock"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.FalseBlock, err = jc.readStatement(*raw); err != nil {
			return nil, err
		}
	}

	// IfPos
	jc.tracer.Trace("Reading IfPos")
	if raw, err := data.readPropertyBytes("ifpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.IfPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// TrueBlock
	jc.tracer.Trace("Reading TrueBlock")
	if raw, err := data.readProperty("trueblock"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.TrueBlock, err = jc.readBlockStatement(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readImportDecl(data rawJsonObject) (*ast.ImportDecl, error) {
	jc.tracer.PushMethod("readImportDecl", "")
	defer jc.tracer.PopMethod("readImportDecl")

	if data.AstType != "ImportDecl" {
		return nil, fmt.Errorf("expected '_t' property in 'ImportDecl' object to be 'ImportDecl' but got %q", data.AstType)
	}
	obj := ast.ImportDecl{}

	// Alias
	jc.tracer.Trace("Reading Alias")
	if raw, err := data.readProperty("alias"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Alias, err = jc.readIdent(*raw); err != nil {
			return nil, err
		}
	}

	// AsPos
	jc.tracer.Trace("Reading AsPos")
	if raw, err := data.readPropertyBytes("aspos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.AsPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Doc
	jc.tracer.Trace("Reading Doc")
	if raw, err := data.readProperty("doc"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Doc, err = jc.readComments(*raw); err != nil {
			return nil, err
		}
	}

	// ImportPos
	jc.tracer.Trace("Reading ImportPos")
	if raw, err := data.readPropertyBytes("importpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ImportPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Name
	jc.tracer.Trace("Reading Name")
	if raw, err := data.readProperty("name"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Name, err = jc.readBasicLit(*raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readIndexExpression(data rawJsonObject) (*ast.IndexExpression, error) {
	jc.tracer.PushMethod("readIndexExpression", "")
	defer jc.tracer.PopMethod("readIndexExpression")

	if data.AstType != "IndexExpression" {
		return nil, fmt.Errorf("expected '_t' property in 'IndexExpression' object to be 'IndexExpression' but got %q", data.AstType)
	}
	obj := ast.IndexExpression{}

	// Index
	jc.tracer.Trace("Reading Index")
	if raw, err := data.readProperty("index"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Index, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// LeftBrack
	jc.tracer.Trace("Reading LeftBrack")
	if raw, err := data.readPropertyBytes("leftbrack"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LeftBrack, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RightBrack
	jc.tracer.Trace("Reading RightBrack")
	if raw, err := data.readPropertyBytes("rightbrack"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RightBrack, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if raw, err := data.readProperty("value"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Value, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readForStatement(data rawJsonObject) (*ast.ForStatement, error) {
	jc.tracer.PushMethod("readForStatement", "")
	defer jc.tracer.PopMethod("readForStatement")

	if data.AstType != "ForStatement" {
		return nil, fmt.Errorf("expected '_t' property in 'ForStatement' object to be 'ForStatement' but got %q", data.AstType)
	}
	obj := ast.ForStatement{}

	// AsPos
	jc.tracer.Trace("Reading AsPos")
	if raw, err := data.readPropertyBytes("aspos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.AsPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Block
	jc.tracer.Trace("Reading Block")
	if raw, err := data.readProperty("block"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Block, err = jc.readBlockStatement(*raw); err != nil {
			return nil, err
		}
	}

	// ForPos
	jc.tracer.Trace("Reading ForPos")
	if raw, err := data.readPropertyBytes("forpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ForPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Iterable
	jc.tracer.Trace("Reading Iterable")
	if raw, err := data.readProperty("iterable"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Iterable, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// Iterator1
	jc.tracer.Trace("Reading Iterator1")
	if raw, err := data.readProperty("iterator1"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Iterator1, err = jc.readIdent(*raw); err != nil {
			return nil, err
		}
	}

	// Iterator2
	jc.tracer.Trace("Reading Iterator2")
	if raw, err := data.readProperty("iterator2"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Iterator2, err = jc.readIdent(*raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readGroupExpression(data rawJsonObject) (*ast.GroupExpression, error) {
	jc.tracer.PushMethod("readGroupExpression", "")
	defer jc.tracer.PopMethod("readGroupExpression")

	if data.AstType != "GroupExpression" {
		return nil, fmt.Errorf("expected '_t' property in 'GroupExpression' object to be 'GroupExpression' but got %q", data.AstType)
	}
	obj := ast.GroupExpression{}

	// LeftParen
	jc.tracer.Trace("Reading LeftParen")
	if raw, err := data.readPropertyBytes("leftparen"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LeftParen, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RightParen
	jc.tracer.Trace("Reading RightParen")
	if raw, err := data.readPropertyBytes("rightparen"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RightParen, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if raw, err := data.readProperty("value"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Value, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readKeyedElementExpression(data rawJsonObject) (*ast.KeyedElementExpression, error) {
	jc.tracer.PushMethod("readKeyedElementExpression", "")
	defer jc.tracer.PopMethod("readKeyedElementExpression")

	if data.AstType != "KeyedElementExpression" {
		return nil, fmt.Errorf("expected '_t' property in 'KeyedElementExpression' object to be 'KeyedElementExpression' but got %q", data.AstType)
	}
	obj := ast.KeyedElementExpression{}

	// ColonPos
	jc.tracer.Trace("Reading ColonPos")
	if raw, err := data.readPropertyBytes("colonpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ColonPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Key
	jc.tracer.Trace("Reading Key")
	if raw, err := data.readProperty("key"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Key, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if raw, err := data.readProperty("value"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Value, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readListLit(data rawJsonObject) (*ast.ListLit, error) {
	jc.tracer.PushMethod("readListLit", "")
	defer jc.tracer.PopMethod("readListLit")

	if data.AstType != "ListLit" {
		return nil, fmt.Errorf("expected '_t' property in 'ListLit' object to be 'ListLit' but got %q", data.AstType)
	}
	obj := ast.ListLit{}

	// Items
	jc.tracer.Trace("Reading Items")
	if raw, err := data.readPropertyBytes("items"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueList[ast.Expression](*raw, jc.readExpression); err != nil {
			return nil, err
		} else {
			obj.Items = *val
		}
	}

	// LeftBrack
	jc.tracer.Trace("Reading LeftBrack")
	if raw, err := data.readPropertyBytes("leftbrack"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LeftBrack, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RightBrack
	jc.tracer.Trace("Reading RightBrack")
	if raw, err := data.readPropertyBytes("rightbrack"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RightBrack, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readMapLit(data rawJsonObject) (*ast.MapLit, error) {
	jc.tracer.PushMethod("readMapLit", "")
	defer jc.tracer.PopMethod("readMapLit")

	if data.AstType != "MapLit" {
		return nil, fmt.Errorf("expected '_t' property in 'MapLit' object to be 'MapLit' but got %q", data.AstType)
	}
	obj := ast.MapLit{}

	// Elements
	jc.tracer.Trace("Reading Elements")
	if raw, err := data.readPropertyBytes("elements"); err != nil {
		return nil, err
	} else if raw != nil {
		if val, err := readValueList[ast.Expression](*raw, jc.readExpression); err != nil {
			return nil, err
		} else {
			obj.Elements = *val
		}
	}

	// LeftBrace
	jc.tracer.Trace("Reading LeftBrace")
	if raw, err := data.readPropertyBytes("leftbrace"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LeftBrace, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RightBrace
	jc.tracer.Trace("Reading RightBrace")
	if raw, err := data.readPropertyBytes("rightbrace"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RightBrace, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readParamDecl(data rawJsonObject) (*ast.ParamDecl, error) {
	jc.tracer.PushMethod("readParamDecl", "")
	defer jc.tracer.PopMethod("readParamDecl")

	if data.AstType != "ParamDecl" {
		return nil, fmt.Errorf("expected '_t' property in 'ParamDecl' object to be 'ParamDecl' but got %q", data.AstType)
	}
	obj := ast.ParamDecl{}

	// Default
	jc.tracer.Trace("Reading Default")
	if raw, err := data.readProperty("default"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Default, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// DefaultPos
	jc.tracer.Trace("Reading DefaultPos")
	if raw, err := data.readPropertyBytes("defaultpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.DefaultPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Doc
	jc.tracer.Trace("Reading Doc")
	if raw, err := data.readProperty("doc"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Doc, err = jc.readComments(*raw); err != nil {
			return nil, err
		}
	}

	// Name
	jc.tracer.Trace("Reading Name")
	if raw, err := data.readProperty("name"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Name, err = jc.readIdent(*raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readQuantExpression(data rawJsonObject) (*ast.QuantExpression, error) {
	jc.tracer.PushMethod("readQuantExpression", "")
	defer jc.tracer.PopMethod("readQuantExpression")

	if data.AstType != "QuantExpression" {
		return nil, fmt.Errorf("expected '_t' property in 'QuantExpression' object to be 'QuantExpression' but got %q", data.AstType)
	}
	obj := ast.QuantExpression{}

	// AsPos
	jc.tracer.Trace("Reading AsPos")
	if raw, err := data.readPropertyBytes("aspos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.AsPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// CommaPos
	jc.tracer.Trace("Reading CommaPos")
	if raw, err := data.readPropertyBytes("commapos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.CommaPos, err = jc.readSourceRangePtr(raw); err != nil {
			return nil, err
		}
	}

	// LeftBrace
	jc.tracer.Trace("Reading LeftBrace")
	if raw, err := data.readPropertyBytes("leftbrace"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LeftBrace, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Name1
	jc.tracer.Trace("Reading Name1")
	if raw, err := data.readProperty("name1"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Name1, err = jc.readIdent(*raw); err != nil {
			return nil, err
		}
	}

	// Name2
	jc.tracer.Trace("Reading Name2")
	if raw, err := data.readProperty("name2"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Name2, err = jc.readIdent(*raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Op
	jc.tracer.Trace("Reading Op")
	if val, err := readValue[token.TokenType](data.Properties["op"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'op' property in 'QuantExpression' object: %s", err)
	} else {
		obj.Op = *val
	}

	// OpPos
	jc.tracer.Trace("Reading OpPos")
	if raw, err := data.readPropertyBytes("oppos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.OpPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Quantifier
	jc.tracer.Trace("Reading Quantifier")
	if raw, err := data.readProperty("quantifier"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Quantifier, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// RightBrace
	jc.tracer.Trace("Reading RightBrace")
	if raw, err := data.readPropertyBytes("rightbrace"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RightBrace, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if raw, err := data.readProperty("value"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Value, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readReturnStatement(data rawJsonObject) (*ast.ReturnStatement, error) {
	jc.tracer.PushMethod("readReturnStatement", "")
	defer jc.tracer.PopMethod("readReturnStatement")

	if data.AstType != "ReturnStatement" {
		return nil, fmt.Errorf("expected '_t' property in 'ReturnStatement' object to be 'ReturnStatement' but got %q", data.AstType)
	}
	obj := ast.ReturnStatement{}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Result
	jc.tracer.Trace("Reading Result")
	if raw, err := data.readProperty("result"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Result, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// ReturnPos
	jc.tracer.Trace("Reading ReturnPos")
	if raw, err := data.readPropertyBytes("returnpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.ReturnPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readRuleExpression(data rawJsonObject) (*ast.RuleExpression, error) {
	jc.tracer.PushMethod("readRuleExpression", "")
	defer jc.tracer.PopMethod("readRuleExpression")

	if data.AstType != "RuleExpression" {
		return nil, fmt.Errorf("expected '_t' property in 'RuleExpression' object to be 'RuleExpression' but got %q", data.AstType)
	}
	obj := ast.RuleExpression{}

	// Doc
	jc.tracer.Trace("Reading Doc")
	if raw, err := data.readProperty("doc"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Doc, err = jc.readComments(*raw); err != nil {
			return nil, err
		}
	}

	// LeftBracePos
	jc.tracer.Trace("Reading LeftBracePos")
	if raw, err := data.readPropertyBytes("leftbracepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LeftBracePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RightBracePos
	jc.tracer.Trace("Reading RightBracePos")
	if raw, err := data.readPropertyBytes("rightbracepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RightBracePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RuleTokenPos
	jc.tracer.Trace("Reading RuleTokenPos")
	if raw, err := data.readPropertyBytes("ruletokenpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RuleTokenPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if raw, err := data.readProperty("value"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Value, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// When
	jc.tracer.Trace("Reading When")
	if raw, err := data.readProperty("when"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.When, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// WhenTokenPos
	jc.tracer.Trace("Reading WhenTokenPos")
	if raw, err := data.readPropertyBytes("whentokenpos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.WhenTokenPos, err = jc.readSourceRangePtr(raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readSelectorExpression(data rawJsonObject) (*ast.SelectorExpression, error) {
	jc.tracer.PushMethod("readSelectorExpression", "")
	defer jc.tracer.PopMethod("readSelectorExpression")

	if data.AstType != "SelectorExpression" {
		return nil, fmt.Errorf("expected '_t' property in 'SelectorExpression' object to be 'SelectorExpression' but got %q", data.AstType)
	}
	obj := ast.SelectorExpression{}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Selector
	jc.tracer.Trace("Reading Selector")
	if raw, err := data.readProperty("selector"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Selector, err = jc.readIdent(*raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if raw, err := data.readProperty("value"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Value, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readSliceExpression(data rawJsonObject) (*ast.SliceExpression, error) {
	jc.tracer.PushMethod("readSliceExpression", "")
	defer jc.tracer.PopMethod("readSliceExpression")

	if data.AstType != "SliceExpression" {
		return nil, fmt.Errorf("expected '_t' property in 'SliceExpression' object to be 'SliceExpression' but got %q", data.AstType)
	}
	obj := ast.SliceExpression{}

	// Colon
	jc.tracer.Trace("Reading Colon")
	if raw, err := data.readPropertyBytes("colon"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Colon, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// HighExpr
	jc.tracer.Trace("Reading HighExpr")
	if raw, err := data.readProperty("highexpr"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.HighExpr, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// LeftBrack
	jc.tracer.Trace("Reading LeftBrack")
	if raw, err := data.readPropertyBytes("leftbrack"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LeftBrack, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// LowExpr
	jc.tracer.Trace("Reading LowExpr")
	if raw, err := data.readProperty("lowexpr"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.LowExpr, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RightBrack
	jc.tracer.Trace("Reading RightBrack")
	if raw, err := data.readPropertyBytes("rightbrack"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RightBrack, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Value
	jc.tracer.Trace("Reading Value")
	if raw, err := data.readProperty("value"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.Value, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func(jc * jsonCoder) readUnaryExpression(data rawJsonObject) (*ast.UnaryExpression, error) {
	jc.tracer.PushMethod("readUnaryExpression", "")
	defer jc.tracer.PopMethod("readUnaryExpression")

	if data.AstType != "UnaryExpression" {
		return nil, fmt.Errorf("expected '_t' property in 'UnaryExpression' object to be 'UnaryExpression' but got %q", data.AstType)
	}
	obj := ast.UnaryExpression{}

	// NodePos
	jc.tracer.Trace("Reading NodePos")
	if raw, err := data.readPropertyBytes("nodepos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.NodePos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// Op
	jc.tracer.Trace("Reading Op")
	if val, err := readValue[token.TokenType](data.Properties["op"]); err != nil {
		return nil, fmt.Errorf("could not deserialize 'op' property in 'UnaryExpression' object: %s", err)
	} else {
		obj.Op = *val
	}

	// OpPos
	jc.tracer.Trace("Reading OpPos")
	if raw, err := data.readPropertyBytes("oppos"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.OpPos, err = jc.readSourceRange(raw); err != nil {
			return nil, err
		}
	}

	// RhsExpr
	jc.tracer.Trace("Reading RhsExpr")
	if raw, err := data.readProperty("rhsexpr"); err != nil {
		return nil, err
	} else if raw != nil {
		if obj.RhsExpr, err = jc.readExpression(*raw); err != nil {
			return nil, err
		}
	}

	return &obj, nil
}

func (jc *jsonCoder) readExpression(data rawJsonObject) (ast.Expression, error) {
	switch data.AstType {
	case "BadExpression":
		return jc.readBadExpression(data)
	case "BasicLit":
		return jc.readBasicLit(data)
	case "BinaryExpression":
		return jc.readBinaryExpression(data)
	case "CallExpression":
		return jc.readCallExpression(data)
	case "FuncLit":
		return jc.readFuncLit(data)
	case "Ident":
		return jc.readIdent(data)
	case "IndexExpression":
		return jc.readIndexExpression(data)
	case "GroupExpression":
		return jc.readGroupExpression(data)
	case "KeyedElementExpression":
		return jc.readKeyedElementExpression(data)
	case "ListLit":
		return jc.readListLit(data)
	case "MapLit":
		return jc.readMapLit(data)
	case "QuantExpression":
		return jc.readQuantExpression(data)
	case "RuleExpression":
		return jc.readRuleExpression(data)
	case "SelectorExpression":
		return jc.readSelectorExpression(data)
	case "SliceExpression":
		return jc.readSliceExpression(data)
	case "UnaryExpression":
		return jc.readUnaryExpression(data)

	default:
		return nil, fmt.Errorf("Unknown type %q while deserializing expression", data.AstType)
	}
}

func (jc *jsonCoder) readStatement(data rawJsonObject) (ast.Statement, error) {
	switch data.AstType {
	case "AssignStatement":
		return jc.readAssignStatement(data)
	case "BadStatement":
		return jc.readBadStatement(data)
	case "BlockStatement":
		return jc.readBlockStatement(data)
	case "BranchStatement":
		return jc.readBranchStatement(data)
	case "CaseWhenClause":
		return jc.readCaseWhenClause(data)
	case "CaseStatement":
		return jc.readCaseStatement(data)
	case "EmptyStatement":
		return jc.readEmptyStatement(data)
	case "ExpressionStatement":
		return jc.readExpressionStatement(data)
	case "FuncDecl":
		return jc.readFuncDecl(data)
	case "IfStatement":
		return jc.readIfStatement(data)
	case "ForStatement":
		return jc.readForStatement(data)
	case "ReturnStatement":
		return jc.readReturnStatement(data)

	default:
		return nil, fmt.Errorf("Unknown type %q while deserializing statement", data.AstType)
	}
}
