package ast

// Autogenerated using generate_sentinel_ast_walker.js
// DO NOT MODIFY MANUALLY

import "fmt"

// Custom errors
var _ error = &UnexpectedNodeTypeError{}

type UnexpectedNodeTypeError struct {
	Node Node
	Err  error
}

func (e *UnexpectedNodeTypeError) Error() string {
	return e.Err.Error()
}

// Visitor and Walking
type VisitFunc func(node Node) VisitFunc

func Walk(visitor VisitFunc, node Node) error {
	if visitor = visitor(node); visitor == nil {
		return nil
	}

	switch n := node.(type) {
	case *BadExpression, *BadStatement, *BasicLit, *BranchStatement, *Comment, *EmptyStatement, *Ident:
		// These types have no child types to walk
	case *AssignStatement:
		// LeftExpr
		if n.LeftExpr != nil {
			if err := Walk(visitor, n.LeftExpr); err != nil {
				return err
			}
		}
		// RightExpr
		if n.RightExpr != nil {
			if err := Walk(visitor, n.RightExpr); err != nil {
				return err
			}
		}
	case *BinaryExpression:
		// LeftExpr
		if n.LeftExpr != nil {
			if err := Walk(visitor, n.LeftExpr); err != nil {
				return err
			}
		}
		// RightExpr
		if n.RightExpr != nil {
			if err := Walk(visitor, n.RightExpr); err != nil {
				return err
			}
		}
	case *BlockStatement:
		// Statments
		for _, obj := range n.Statments {
			if obj != nil {
				if err := Walk(visitor, obj); err != nil {
					return err
				}
			}
		}
	case *CallExpression:
		// Args
		for _, obj := range n.Args {
			if obj != nil {
				if err := Walk(visitor, obj); err != nil {
					return err
				}
			}
		}
		// Callee
		if n.Callee != nil {
			if err := Walk(visitor, n.Callee); err != nil {
				return err
			}
		}
	case *CaseWhenClause:
		// Conditions
		for _, obj := range n.Conditions {
			if obj != nil {
				if err := Walk(visitor, obj); err != nil {
					return err
				}
			}
		}
		// Statements
		for _, obj := range n.Statements {
			if obj != nil {
				if err := Walk(visitor, obj); err != nil {
					return err
				}
			}
		}
	case *CaseStatement:
		// Clauses
		if n.Clauses != nil {
			if err := Walk(visitor, n.Clauses); err != nil {
				return err
			}
		}
		// Value
		if n.Value != nil {
			if err := Walk(visitor, n.Value); err != nil {
				return err
			}
		}
	case *Comments:
		// List
		for _, obj := range n.List {
			if obj != nil {
				if err := Walk(visitor, obj); err != nil {
					return err
				}
			}
		}
	case *ExpressionStatement:
		// Expr
		if n.Expr != nil {
			if err := Walk(visitor, n.Expr); err != nil {
				return err
			}
		}
	case *FieldList:
		// Fields
		for _, obj := range n.Fields {
			if obj != nil {
				if err := Walk(visitor, obj); err != nil {
					return err
				}
			}
		}
	case *File:
		// Doc
		if n.Doc != nil {
			if err := Walk(visitor, n.Doc); err != nil {
				return err
			}
		}
		// Imports
		for _, obj := range n.Imports {
			if obj != nil {
				if err := Walk(visitor, obj); err != nil {
					return err
				}
			}
		}
		// Params
		for _, obj := range n.Params {
			if obj != nil {
				if err := Walk(visitor, obj); err != nil {
					return err
				}
			}
		}
		// Statements
		for _, obj := range n.Statements {
			if obj != nil {
				if err := Walk(visitor, obj); err != nil {
					return err
				}
			}
		}
	case *FuncDecl:
		// Body
		if n.Body != nil {
			if err := Walk(visitor, n.Body); err != nil {
				return err
			}
		}
		// Doc
		if n.Doc != nil {
			if err := Walk(visitor, n.Doc); err != nil {
				return err
			}
		}
		// Name
		if n.Name != nil {
			if err := Walk(visitor, n.Name); err != nil {
				return err
			}
		}
		// Params
		if n.Params != nil {
			if err := Walk(visitor, n.Params); err != nil {
				return err
			}
		}
	case *FuncLit:
		// Body
		if n.Body != nil {
			if err := Walk(visitor, n.Body); err != nil {
				return err
			}
		}
		// Params
		if n.Params != nil {
			if err := Walk(visitor, n.Params); err != nil {
				return err
			}
		}
	case *IfStatement:
		// Condition
		if n.Condition != nil {
			if err := Walk(visitor, n.Condition); err != nil {
				return err
			}
		}
		// FalseBlock
		if n.FalseBlock != nil {
			if err := Walk(visitor, n.FalseBlock); err != nil {
				return err
			}
		}
		// TrueBlock
		if n.TrueBlock != nil {
			if err := Walk(visitor, n.TrueBlock); err != nil {
				return err
			}
		}
	case *ImportDecl:
		// Alias
		if n.Alias != nil {
			if err := Walk(visitor, n.Alias); err != nil {
				return err
			}
		}
		// Doc
		if n.Doc != nil {
			if err := Walk(visitor, n.Doc); err != nil {
				return err
			}
		}
		// Name
		if n.Name != nil {
			if err := Walk(visitor, n.Name); err != nil {
				return err
			}
		}
	case *IndexExpression:
		// Index
		if n.Index != nil {
			if err := Walk(visitor, n.Index); err != nil {
				return err
			}
		}
		// Value
		if n.Value != nil {
			if err := Walk(visitor, n.Value); err != nil {
				return err
			}
		}
	case *ForStatement:
		// Block
		if n.Block != nil {
			if err := Walk(visitor, n.Block); err != nil {
				return err
			}
		}
		// Iterable
		if n.Iterable != nil {
			if err := Walk(visitor, n.Iterable); err != nil {
				return err
			}
		}
		// Iterator1
		if n.Iterator1 != nil {
			if err := Walk(visitor, n.Iterator1); err != nil {
				return err
			}
		}
		// Iterator2
		if n.Iterator2 != nil {
			if err := Walk(visitor, n.Iterator2); err != nil {
				return err
			}
		}
	case *GroupExpression:
		// Value
		if n.Value != nil {
			if err := Walk(visitor, n.Value); err != nil {
				return err
			}
		}
	case *KeyedElementExpression:
		// Key
		if n.Key != nil {
			if err := Walk(visitor, n.Key); err != nil {
				return err
			}
		}
		// Value
		if n.Value != nil {
			if err := Walk(visitor, n.Value); err != nil {
				return err
			}
		}
	case *ListLit:
		// Items
		for _, obj := range n.Items {
			if obj != nil {
				if err := Walk(visitor, obj); err != nil {
					return err
				}
			}
		}
	case *MapLit:
		// Elements
		for _, obj := range n.Elements {
			if obj != nil {
				if err := Walk(visitor, obj); err != nil {
					return err
				}
			}
		}
	case *ParamDecl:
		// Default
		if n.Default != nil {
			if err := Walk(visitor, n.Default); err != nil {
				return err
			}
		}
		// Doc
		if n.Doc != nil {
			if err := Walk(visitor, n.Doc); err != nil {
				return err
			}
		}
		// Name
		if n.Name != nil {
			if err := Walk(visitor, n.Name); err != nil {
				return err
			}
		}
	case *QuantExpression:
		// Name1
		if n.Name1 != nil {
			if err := Walk(visitor, n.Name1); err != nil {
				return err
			}
		}
		// Name2
		if n.Name2 != nil {
			if err := Walk(visitor, n.Name2); err != nil {
				return err
			}
		}
		// Quantifier
		if n.Quantifier != nil {
			if err := Walk(visitor, n.Quantifier); err != nil {
				return err
			}
		}
		// Value
		if n.Value != nil {
			if err := Walk(visitor, n.Value); err != nil {
				return err
			}
		}
	case *ReturnStatement:
		// Result
		if n.Result != nil {
			if err := Walk(visitor, n.Result); err != nil {
				return err
			}
		}
	case *RuleExpression:
		// Doc
		if n.Doc != nil {
			if err := Walk(visitor, n.Doc); err != nil {
				return err
			}
		}
		// Value
		if n.Value != nil {
			if err := Walk(visitor, n.Value); err != nil {
				return err
			}
		}
		// When
		if n.When != nil {
			if err := Walk(visitor, n.When); err != nil {
				return err
			}
		}
	case *SelectorExpression:
		// Selector
		if n.Selector != nil {
			if err := Walk(visitor, n.Selector); err != nil {
				return err
			}
		}
		// Value
		if n.Value != nil {
			if err := Walk(visitor, n.Value); err != nil {
				return err
			}
		}
	case *SliceExpression:
		// HighExpr
		if n.HighExpr != nil {
			if err := Walk(visitor, n.HighExpr); err != nil {
				return err
			}
		}
		// LowExpr
		if n.LowExpr != nil {
			if err := Walk(visitor, n.LowExpr); err != nil {
				return err
			}
		}
		// Value
		if n.Value != nil {
			if err := Walk(visitor, n.Value); err != nil {
				return err
			}
		}
	case *UnaryExpression:
		// RightExpr
		if n.RightExpr != nil {
			if err := Walk(visitor, n.RightExpr); err != nil {
				return err
			}
		}

	default:
		return &UnexpectedNodeTypeError{
			Node: n,
			Err:  fmt.Errorf("unexpected node type %T when walking", n),
		}
	}

	visitor(nil)
	return nil
}
