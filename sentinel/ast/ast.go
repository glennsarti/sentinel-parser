package ast

// Autogenerated using generate_sentinel_ast.js
// DO NOT MODIFY MANUALLY

import (
	"github.com/glennsarti/sentinel-parser/position"
	"github.com/glennsarti/sentinel-parser/sentinel/token"
)

// The base Node interface
type Node interface {
	Position() position.SourceRange
}

// All statement nodes implement this
type Statement interface {
	Node
	statementNode()
}

// All expression nodes implement this
type Expression interface {
	Node
	expressionNode()
}

type AssignStatement struct {
	AssignOp    token.TokenType
	AssignOpPos position.SourceRange
	LeftExpr    Expression
	NodePos     position.SourceRange
	RightExpr   Expression
}

type BadExpression struct {
	NodePos position.SourceRange
}

type BadStatement struct {
	NodePos position.SourceRange
}

type BasicLit struct {
	Kind    token.TokenType
	NodePos position.SourceRange
	Value   string
}

type BinaryExpression struct {
	LeftExpr  Expression
	NodePos   position.SourceRange
	Op        token.TokenType
	OpPos     position.SourceRange
	RightExpr Expression
}

type BlockStatement struct {
	LeftBrace  position.SourceRange
	NodePos    position.SourceRange
	RightBrace position.SourceRange
	Statments  []Statement
}

type BranchStatement struct {
	Kind    token.TokenType
	NodePos position.SourceRange
}

type CallExpression struct {
	Args       []Expression
	Callee     Expression
	LeftParen  position.SourceRange
	NodePos    position.SourceRange
	RightParen position.SourceRange
}

type CaseWhenClause struct {
	ColonPos   position.SourceRange
	Conditions []Expression
	NodePos    position.SourceRange
	Statements []Statement
	TokenKind  token.TokenType
	TokenPos   position.SourceRange
}

type CaseStatement struct {
	CasePos position.SourceRange
	Clauses *BlockStatement
	NodePos position.SourceRange
	Value   Expression
}

type Comment struct {
	NodePos   position.SourceRange
	Prefix    string // The #, // or /* prefix
	PrefixPos position.SourceRange
	Text      string // Excludes trailing line feeds and trailing '*/'
	TextPos   position.SourceRange
}

type Comments struct {
	List    []*Comment
	NodePos position.SourceRange
}

type EmptyStatement struct {
	Implied bool
	NodePos position.SourceRange
}

type ExpressionStatement struct {
	Expr    Expression
	NodePos position.SourceRange
}

type FieldList struct {
	Fields     []*Ident
	LeftParen  position.SourceRange
	NodePos    position.SourceRange
	RightParen position.SourceRange
}

// A Sentinel File
type File struct {
	Doc        *Comments
	Imports    []*ImportDecl
	NodePos    position.SourceRange
	Params     []*ParamDecl
	Statements []Statement
}

type FuncDecl struct {
	Body    *BlockStatement
	Doc     *Comments
	FuncPos position.SourceRange
	Name    *Ident
	NodePos position.SourceRange
	Params  *FieldList
}

type FuncLit struct {
	Body    *BlockStatement
	FuncPos position.SourceRange
	NodePos position.SourceRange
	Params  *FieldList
}

type Ident struct {
	Name    string
	NodePos position.SourceRange
}

type IfStatement struct {
	Condition  Expression
	ElsePos    position.SourceRange
	FalseBlock Statement
	IfPos      position.SourceRange
	NodePos    position.SourceRange
	TrueBlock  *BlockStatement
}

type ImportDecl struct {
	Alias     *Ident
	AsPos     position.SourceRange
	Doc       *Comments
	ImportPos position.SourceRange
	Name      *BasicLit
	NodePos   position.SourceRange
}

type IndexExpression struct {
	Index      Expression
	LeftBrack  position.SourceRange
	NodePos    position.SourceRange
	RightBrack position.SourceRange
	Value      Expression
}

type ForStatement struct {
	AsPos     position.SourceRange
	Block     *BlockStatement
	ForPos    position.SourceRange
	Iterable  Expression
	Iterator1 *Ident
	Iterator2 *Ident
	NodePos   position.SourceRange
}

type GroupExpression struct {
	LeftParen  position.SourceRange
	NodePos    position.SourceRange
	RightParen position.SourceRange
	Value      Expression
}

type KeyedElementExpression struct {
	ColonPos position.SourceRange
	Key      Expression
	NodePos  position.SourceRange
	Value    Expression
}

type ListLit struct {
	Items      []Expression
	LeftBrack  position.SourceRange
	NodePos    position.SourceRange
	RightBrack position.SourceRange
}

type MapLit struct {
	Elements   []Expression
	LeftBrace  position.SourceRange
	NodePos    position.SourceRange
	RightBrace position.SourceRange
}

type ParamDecl struct {
	Default    Expression
	DefaultPos position.SourceRange
	Doc        *Comments
	Name       *Ident
	NodePos    position.SourceRange
}

type QuantExpression struct {
	AsPos      position.SourceRange
	CommaPos   *position.SourceRange
	LeftBrace  position.SourceRange
	Name1      *Ident
	Name2      *Ident
	NodePos    position.SourceRange
	Op         token.TokenType
	OpPos      position.SourceRange
	Quantifier Expression
	RightBrace position.SourceRange
	Value      Expression
}

type ReturnStatement struct {
	NodePos   position.SourceRange
	Result    Expression
	ReturnPos position.SourceRange
}

type RuleExpression struct {
	Doc           *Comments
	LeftBracePos  position.SourceRange
	NodePos       position.SourceRange
	RightBracePos position.SourceRange
	RuleTokenPos  position.SourceRange
	Value         Expression
	When          Expression
	WhenTokenPos  *position.SourceRange
}

// <Value>.<Selector>
type SelectorExpression struct {
	NodePos  position.SourceRange
	Selector *Ident
	Value    Expression
}

// <Expression>[<Low>:<High>]
type SliceExpression struct {
	Colon      position.SourceRange
	HighExpr   Expression
	LeftBrack  position.SourceRange
	LowExpr    Expression
	NodePos    position.SourceRange
	RightBrack position.SourceRange
	Value      Expression
}

type UnaryExpression struct {
	NodePos   position.SourceRange
	Op        token.TokenType
	OpPos     position.SourceRange
	RightExpr Expression
}

// All Nodes must implement Position()
func (o *AssignStatement) Position() position.SourceRange        { return o.NodePos }
func (o *BadExpression) Position() position.SourceRange          { return o.NodePos }
func (o *BadStatement) Position() position.SourceRange           { return o.NodePos }
func (o *BasicLit) Position() position.SourceRange               { return o.NodePos }
func (o *BinaryExpression) Position() position.SourceRange       { return o.NodePos }
func (o *BlockStatement) Position() position.SourceRange         { return o.NodePos }
func (o *BranchStatement) Position() position.SourceRange        { return o.NodePos }
func (o *CallExpression) Position() position.SourceRange         { return o.NodePos }
func (o *CaseWhenClause) Position() position.SourceRange         { return o.NodePos }
func (o *CaseStatement) Position() position.SourceRange          { return o.NodePos }
func (o *Comment) Position() position.SourceRange                { return o.NodePos }
func (o *Comments) Position() position.SourceRange               { return o.NodePos }
func (o *EmptyStatement) Position() position.SourceRange         { return o.NodePos }
func (o *ExpressionStatement) Position() position.SourceRange    { return o.NodePos }
func (o *FieldList) Position() position.SourceRange              { return o.NodePos }
func (o *File) Position() position.SourceRange                   { return o.NodePos }
func (o *FuncDecl) Position() position.SourceRange               { return o.NodePos }
func (o *FuncLit) Position() position.SourceRange                { return o.NodePos }
func (o *Ident) Position() position.SourceRange                  { return o.NodePos }
func (o *IfStatement) Position() position.SourceRange            { return o.NodePos }
func (o *ImportDecl) Position() position.SourceRange             { return o.NodePos }
func (o *IndexExpression) Position() position.SourceRange        { return o.NodePos }
func (o *ForStatement) Position() position.SourceRange           { return o.NodePos }
func (o *GroupExpression) Position() position.SourceRange        { return o.NodePos }
func (o *KeyedElementExpression) Position() position.SourceRange { return o.NodePos }
func (o *ListLit) Position() position.SourceRange                { return o.NodePos }
func (o *MapLit) Position() position.SourceRange                 { return o.NodePos }
func (o *ParamDecl) Position() position.SourceRange              { return o.NodePos }
func (o *QuantExpression) Position() position.SourceRange        { return o.NodePos }
func (o *ReturnStatement) Position() position.SourceRange        { return o.NodePos }
func (o *RuleExpression) Position() position.SourceRange         { return o.NodePos }
func (o *SelectorExpression) Position() position.SourceRange     { return o.NodePos }
func (o *SliceExpression) Position() position.SourceRange        { return o.NodePos }
func (o *UnaryExpression) Position() position.SourceRange        { return o.NodePos }

// All expressions implement expressionNode
func (o *BadExpression) expressionNode()          {}
func (o *BasicLit) expressionNode()               {}
func (o *BinaryExpression) expressionNode()       {}
func (o *CallExpression) expressionNode()         {}
func (o *FuncLit) expressionNode()                {}
func (o *Ident) expressionNode()                  {}
func (o *IndexExpression) expressionNode()        {}
func (o *GroupExpression) expressionNode()        {}
func (o *KeyedElementExpression) expressionNode() {}
func (o *ListLit) expressionNode()                {}
func (o *MapLit) expressionNode()                 {}
func (o *QuantExpression) expressionNode()        {}
func (o *RuleExpression) expressionNode()         {}
func (o *SelectorExpression) expressionNode()     {}
func (o *SliceExpression) expressionNode()        {}
func (o *UnaryExpression) expressionNode()        {}

// All statements implement statementNode
func (o *AssignStatement) statementNode()     {}
func (o *BadStatement) statementNode()        {}
func (o *BlockStatement) statementNode()      {}
func (o *BranchStatement) statementNode()     {}
func (o *CaseWhenClause) statementNode()      {}
func (o *CaseStatement) statementNode()       {}
func (o *EmptyStatement) statementNode()      {}
func (o *ExpressionStatement) statementNode() {}
func (o *FuncDecl) statementNode()            {}
func (o *IfStatement) statementNode()         {}
func (o *ForStatement) statementNode()        {}
func (o *ReturnStatement) statementNode()     {}
