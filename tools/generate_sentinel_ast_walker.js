var fs = require("fs");
var path = require("path");
var cp = require("child_process");

console.log(`Running ${__filename}`)

const scriptDir = __dirname;
const root = path.join(scriptDir, "..");
const srcFile = path.join(scriptDir, "sentinel_ast_schema.json");
const outFile = path.join(root, "sentinel", "ast", "walk.go");

content = "";
schema = JSON.parse(fs.readFileSync(srcFile, { encoding: "utf8" }));

function generateType(objSchema) {
  let output = "";

  for (let index = 0; index < objSchema.properties.length; index++) {
    prop = objSchema.properties[index];

    switch (prop.type) {
      case "*position.SourceRange":
      case "bool":
      case "position.SourceRange":
      case "string":
      case "token.TokenType":
        // These types aren't walkable
        break;

      case "*BasicLit":
      case "*BlockStatement":
      case "*Comments":
      case "*FieldList":
      case "*Ident":
      case "Expression":
      case "Statement":
          output +=
          `\t\t// ${prop.name}\n` +
          `\t\tif n.${prop.name} != nil {\n` +
          `\t\t\tif err := Walk(visitor, n.${prop.name}); err != nil {\n` +
          `\t\t\t\treturn err\n` +
          `\t\t\t}\n` +
          `\t\t}\n`;
        break;

      case "[]Expression":
      case "[]*Comment":
      case "[]*Ident":
      case "[]*ImportDecl":
      case "[]*ParamDecl":
      case "[]Statement":
          output +=
          `\t\t// ${prop.name}\n` +

          `\t\tfor _, obj := range n.${prop.name} {\n` +
          `\t\t\tif obj != nil {\n` +
          `\t\t\t\tif err := Walk(visitor, obj); err != nil {\n` +
          `\t\t\t\t\treturn err\n` +
          `\t\t\t\t}\n` +
          `\t\t\t}\n` +
          `\t\t}\n`;
        break;


      default:
        throw new Error("Unknown property type '" + prop.type + "' for " + JSON.stringify(prop));
    }
  }

  if (output !== "") {
    output = `\tcase *${objSchema.name}:\n` + output;
  }

  return output;
}

function generateTypes() {
  let output = "";

  noChildTypes = [];

  for (let index = 0; index < schema.length; index++) {
    let typeOutput = generateType(schema[index]);
    if (typeOutput === "") {
      noChildTypes.push("*" + schema[index].name);
    } else {
      output = output + typeOutput;
    }
  }

  if (noChildTypes.length > 0) {
    output = `\tcase ${noChildTypes.join(", ")}:\n\t\t\/\/ These types have no child types to walk\n` + output;
  }

  return output;
}

content = `package ast

// Autogenerated using generate_sentinel_ast_walker.js
// DO NOT MODIFY MANUALLY

import "fmt"

// Custom errors
var _ error = &UnexpectedNodeTypeError{}

type UnexpectedNodeTypeError struct {
	Node Node
	Err  error
}

func (e *UnexpectedNodeTypeError) Error() string {
	return e.Err.Error()
}

// Visitor and Walking
type VisitFunc func(node Node) (VisitFunc)

func Walk(visitor VisitFunc, node Node) error {
	if visitor = visitor(node); visitor == nil {
		return nil
	}

  switch n := node.(type) {
${generateTypes()}
	default:
		return &UnexpectedNodeTypeError{
			Node: n,
			Err:  fmt.Errorf("unexpected node type %T when walking", n),
		}
	}

	visitor(nil)
	return nil
}
`;

console.log(`Writing ${outFile}...`);
fs.writeFileSync(outFile, content, { encoding: "utf8" });
cp.execSync(`go fmt ${outFile}`);
