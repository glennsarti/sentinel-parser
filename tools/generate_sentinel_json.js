var fs = require("fs");
var path = require("path");
var cp = require("child_process");

console.log(`Running ${__filename}`)

const scriptDir = __dirname;
const root = path.join(scriptDir, "..");
const srcFile = path.join(scriptDir, "sentinel_ast_schema.json");
const outWriteFile = path.join(root, "sentinel", "serialization", "json", "json_write_generated.go");
const outReadFile = path.join(root, "sentinel", "serialization", "json", "json_read_generated.go");

content = "";
schema = JSON.parse(fs.readFileSync(srcFile, { encoding: "utf8" }));

// Serializing
function generateWriteProperty(propName, propType) {
	switch (propType) {
		case "string":
			return `\tif err := jc.writeLiteralString(${propName}, writer); err != nil { return err }`;
		case "position.SourceRange":
			return `\tif err := jc.writeSourceRange(${propName}, writer); err != nil { return err }`;
		case "*position.SourceRange":
			return `\tif err := jc.writeSourceRangePointer(${propName}, writer); err != nil { return err }`;
		case "token.TokenType":
			return `\tif err := jc.writeLiteralString(string(${propName}), writer); err != nil { return err }`;
		case "bool":
			return `\tif err := jc.writeLiteralBool(${propName}, writer); err != nil { return err }`;

		case "*Ident":
		case "*Comments":
		case "*FieldList":
		case "*BlockStatement":
		case "Expression":
		case "Statement":
		case "*BasicLit":
			return `\tif err := jc.writeNilableNode(${propName}, writer); err != nil { return err }`;

		case "[]*Comment":
		case "[]*Ident":
		case "[]*ImportDecl":
		case "[]*ParamDecl":
		case "[]Expression":
		case "[]Statement":
			// All items in this case implement the ast.Node interface so there's
			// no need to prefix the writeList with it.
			return `\tif err := writeList(${propName}, jc, writer); err != nil { return err }`;

		default:
			throw new Error("(generateWriteProperty) Unknown property type: " + propType);
	}
}

function generateWriteType(objSchema) {
	let output = `\nfunc (jc *jsonCoder) write${objSchema.name}(node *ast.${objSchema.name}, writer io.Writer) error {\n` +
		`\tif node == nil {\n` +
		`\t\t_, err := fmt.Fprintf(writer, "null")\n` +
		`\t\treturn err\n` +
		`\t}\n` +
		`\tif err := jc.writeHeader("${objSchema.name}", writer); err != nil { return err }\n`

	for (let index = 0; index < objSchema.properties.length; index++) {
		let prop = objSchema.properties[index];
		let jsonPropName = prop.name.toLowerCase();

		output += `\t// ${prop.name}\n` +
			`\tif _, err := fmt.Fprint(writer, \``
		if (index > 0) { output += "," }
		output += `"${jsonPropName}":\`); err != nil { return err }\n` +
			generateWriteProperty("node." + prop.name, prop.type) +
			"\n";
	}

	output = output + "\treturn jc.writeFooter(writer)\n" +
		"}\n";

	return output;
}

function generateWriteTypes() {
	let output = "";

	for (let index = 0; index < schema.length; index++) {
		output = output + generateWriteType(schema[index]);
	}

	return output;
}

function generateWriteVisitSwitch() {
	let output = "";

	for (let index = 0; index < schema.length; index++) {
		output = output + `\tcase *ast.${schema[index].name}:\n`
		output = output + `\t\treturn jc.write${schema[index].name}(n, writer)\n`
	}

	return output;
}

content = `package json

// Autogenerated using generate_sentinel_json.js
// DO NOT MODIFY MANUALLY
//
// This is not most effecient or quickest way to serialize to JSON, but it works!

import (
	"fmt"
	"io"

	"github.com/glennsarti/sentinel-parser/sentinel/ast"
)

func (jc *jsonCoder) write(node ast.Node, writer io.Writer) error {
	if node == nil {
		return fmt.Errorf("received nil while serializing")
	}

	switch n := node.(type) {
${generateWriteVisitSwitch()}
	default:
		return fmt.Errorf("unexpected node type %T when serializing", node)
	}
}

${generateWriteTypes()}
`;

console.log(`Writing ${outWriteFile}...`);
fs.writeFileSync(outWriteFile, content, { encoding: "utf8" });
cp.execSync(`go fmt ${outWriteFile}`)

// Deserializing
function generateReadVisitSwitch() {
	let output = "";

	for (let index = 0; index < schema.length; index++) {
		output = output + `\tcase "${schema[index].name}":\n`
		output = output + `\t\treturn jc.read${schema[index].name}(raw)\n`
	}

	return output;
}

function generatReadProperty(propName, jsonPropName, propType, className) {
	switch (propType) {
		case "token.TokenType":
		case "bool":
		case "[]string":
		case "string":
			return `\tif val, err := readValue[${propType}](data.Properties["${jsonPropName}"]); err != nil {\n` +
				`\t\treturn nil, fmt.Errorf("could not deserialize '${jsonPropName}' property in '${className}' object: %s", err)\n` +
				`\t} else {\n` +
				`\t\tobj.${propName} = *val\n` +
				`\t}\n`;

		case "*BasicLit":
		case "*BlockStatement":
		case "*Comments":
		case "Expression":
		case "Statement":
		case "*FieldList":
		case "*Ident":
			reader = "read" + propType;
			if (propType.startsWith("*")) {
				reader = "read" + propType.substring(1);
			}
			return `\tif raw, err := data.readProperty("${jsonPropName}"); err != nil {\n` +
				`\t\treturn nil, err\n` +
				`\t} else if raw != nil {\n` +
				`\t\tif obj.${propName}, err = jc.${reader}(*raw); err != nil {\n` +
				`\t\t\treturn nil, err\n` +
				`\t\t}\n` +
				`\t}\n`;

		case "position.SourceRange":
		case "*position.SourceRange":
			reader = "readSourceRange";
			if (propType === "*position.SourceRange") {
				reader = "readSourceRangePtr";
			}
			return `\tif raw, err := data.readPropertyBytes("${jsonPropName}"); err != nil {\n` +
				`\t\treturn nil, err\n` +
				`\t} else if raw != nil {\n` +
				`\t\tif obj.${propName}, err = jc.${reader}(raw); err != nil {\n` +
				`\t\t\treturn nil, err\n` +
				`\t\t}\n` +
				`\t}\n`;

		case "[]*Comment":
		case "[]*Ident":
		case "[]*ImportDecl":
		case "[]*ParamDecl":
		case "[]Expression":
		case "[]Statement":
			baseClass = propType.substring(2);
			listReader = "readValueList";
			if (baseClass.startsWith("*")) {
				baseClass = baseClass.substring(1);
				listReader = "readValuePtrList";
			}
			reader = "read" + baseClass;
			return `\tif raw, err := data.readPropertyBytes("${jsonPropName}"); err != nil {\n` +
				`\t\treturn nil, err\n` +
				`\t} else if raw != nil {\n` +
				`\t\tif val, err := ${listReader}[ast.${baseClass}](*raw, jc.${reader}); err != nil {\n` +
				`\t\t\treturn nil, err\n` +
				`\t\t} else {\n` +
				`\t\t\tobj.${propName} = *val\n` +
				`\t\t}\n` +
				`\t}\n`;

		default:
			throw new Error("(generatReadProperty) Unknown property type: " + propType);
	}
}

function generateReadType(objSchema) {
	let output =
		`\nfunc(jc * jsonCoder) read${objSchema.name}(data rawJsonObject) (*ast.${objSchema.name}, error) {` +
		`\n\tjc.tracer.PushMethod("read${objSchema.name}", "")` +
		`\n\tdefer jc.tracer.PopMethod("read${objSchema.name}")\n` +
		`\n\tif data.AstType != "${objSchema.name}" {` +
		`\n\t\treturn nil, fmt.Errorf("expected '_t' property in '${objSchema.name}' object to be '${objSchema.name}' but got %q", data.AstType)` +
		`\n\t}` +
		`\n\tobj := ast.${objSchema.name}{}\n\n`;

	for (let index = 0; index < objSchema.properties.length; index++) {
		let prop = objSchema.properties[index];
		let jsonPropName = prop.name.toLowerCase();

		output += `\t// ${prop.name}\n` +
			`\tjc.tracer.Trace("Reading ${prop.name}")\n` +
			generatReadProperty(prop.name, jsonPropName, prop.type, objSchema.name) + `\n`;
	}

	output = output + "\treturn &obj, nil\n" +
		"}\n";

	return output;
}

function generateReadIntoTypes() {
	let output = "";

	for (let index = 0; index < schema.length; index++) {
		objSchema = schema[index];

		output = output + `\tcase *ast.${objSchema.name}:\n` +
			`\t\tif resultActual, ok := result.(*ast.${objSchema.name}); !ok {\n` +
			`\t\t\treturn fmt.Errorf("expected to decode a ${objSchema.name} but it was not")\n` +
			`\t\t} else {\n`;
		for (let index = 0; index < objSchema.properties.length; index++) {
			let prop = objSchema.properties[index];

			output += `\t\t\tintoActual.${prop.name} = resultActual.${prop.name}\n`;
		}
		output += `\t\t}\n`
	}

	return output;
}

function generateReadTypes() {
	let output = "";

	noChildTypes = [];

	for (let index = 0; index < schema.length; index++) {
		output = output + generateReadType(schema[index]);
	}

	return output;
}

function generateReadExpressionTypes() {
	let output = "";

	for (let index = 0; index < schema.length; index++) {
		if (schema[index].isExpression) {
			output = output + `\tcase "${schema[index].name}":\n` +
				`\t\treturn jc.read${schema[index].name}(data)\n`
		}
	}

	return output;
}

function generateReadStatementTypes() {
	let output = "";

	for (let index = 0; index < schema.length; index++) {
		if (schema[index].isStatement) {
			output = output + `\tcase "${schema[index].name}":\n` +
				`\t\treturn jc.read${schema[index].name}(data)\n`
		}
	}

	return output;
}

content = `package json

// Autogenerated using generate_sentinel_json.js
// DO NOT MODIFY MANUALLY
//
// This is not most effecient or quickest way to deserialize from JSON
// to an AST, but it works!

import (
	"encoding/json"
	"fmt"

	"github.com/glennsarti/sentinel-parser/sentinel/ast"
	"github.com/glennsarti/sentinel-parser/sentinel/token"
)

type rawJsonObject struct {
	AstType    string                     \`json:"_t"\`
	Properties map[string]json.RawMessage \`json:"_p"\`
}

func (jc *jsonCoder) read(data []byte) (ast.Node, error) {
	raw := rawJsonObject{}
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	switch raw.AstType {
${generateReadVisitSwitch()}
	default:
		return nil, fmt.Errorf("unknown type %q while deserializing", raw.AstType)
	}
}

func (jc *jsonCoder) readInto(data []byte, into ast.Node) error {
	result, err := jc.read(data)
	if err != nil {
		return err
	}

	switch intoActual := into.(type) {
${generateReadIntoTypes()}
	default:
		return fmt.Errorf("unknown type %T while deserializing", intoActual)
	}

	return nil
}

${generateReadTypes()}
func (jc *jsonCoder) readExpression(data rawJsonObject) (ast.Expression, error) {
	switch data.AstType {
${generateReadExpressionTypes()}
	default:
		return nil, fmt.Errorf("unknown type %q while deserializing expression", data.AstType)
	}
}

func (jc *jsonCoder) readStatement(data rawJsonObject) (ast.Statement, error) {
	switch data.AstType {
${generateReadStatementTypes()}
	default:
		return nil, fmt.Errorf("unknown type %q while deserializing statement", data.AstType)
	}
}
`;

console.log(`Writing ${outReadFile}...`);
fs.writeFileSync(outReadFile, content, { encoding: "utf8" });
//cp.execSync(`go fmt ${outReadFile}`);
