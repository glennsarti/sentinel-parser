var fs = require("fs");
var path = require("path");
var cp = require("child_process");

console.log(`Running ${__filename}`)

const scriptDir = __dirname;
const root = path.join(scriptDir, "..");
const srcFile = path.join(scriptDir, "sentinel_ast_schema.json");
const outFile = path.join(root, "sentinel", "ast", "ast.go");

content = "";
schema = JSON.parse(fs.readFileSync(srcFile, { encoding: "utf8" }));

function mungeAsMultilineComment(value) {
  return "// " + value.replace("\n", "\n // ");
}

function mungeAsSingleLineComment(value) {
  return "// " + value.replace("\n", "").trim();
}

function generateType(objSchema) {
  output = "";
  if (objSchema.description) {
    output += mungeAsMultilineComment(objSchema.description) + "\n";
  }
  output += `type ${objSchema.name} struct {\n`;

  for (let index = 0; index < objSchema.properties.length; index++) {
    prop = objSchema.properties[index];

    output = output + "\t" + prop.name + " " + prop.type;
    if (prop.description) {
      output += mungeAsSingleLineComment(prop.description);
    }
    output += "\n";
  }

  output += `}\n`;
  return output;
}

function generateTypes() {
  output = "";

  for (let index = 0; index < schema.length; index++) {
    output = output + generateType(schema[index]) + "\n";
  }

  return output;
}

function generateNodePos() {
  console.log("Generating NodePos boilerplate...");
  output = "// All Nodes must implement Position()\n";

  for (let index = 0; index < schema.length; index++) {
    output =
      output +
      `func (o *${schema[index].name}) Position() position.SourceRange { return o.NodePos }\n`;
  }

  return output;
}

function generateExpressions() {
  console.log("Generating Expression boilerplate...");
  output = "// All expressions implement expressionNode\n";

  for (let index = 0; index < schema.length; index++) {
    if (schema[index].isExpression === true) {
      output = output + `func (o *${schema[index].name}) expressionNode() {}\n`;
    }
  }

  return output;
}

function generateStatements() {
  console.log("Generating Statment boilerplate...");
  output = "// All statements implement statementNode\n";

  for (let index = 0; index < schema.length; index++) {
    if (schema[index].isStatement === true) {
      output = output + `func (o *${schema[index].name}) statementNode() {}\n`;
    }
  }

  return output;
}

content = `package ast

// Autogenerated using generate_sentinel_ast.js
// DO NOT MODIFY MANUALLY

import (
  "github.com/glennsarti/sentinel-parser/position"
	"github.com/glennsarti/sentinel-parser/sentinel/token"
)

// The base Node interface
type Node interface {
	Position() position.SourceRange
}

// All statement nodes implement this
type Statement interface {
	Node
	statementNode()
}

// All expression nodes implement this
type Expression interface {
	Node
	expressionNode()
}

${generateTypes()}
${generateNodePos()}
${generateExpressions()}
${generateStatements()}
`;

console.log(`Writing ${outFile}...`);
fs.writeFileSync(outFile, content, { encoding: "utf8" });
cp.execSync(`go fmt ${outFile}`);
