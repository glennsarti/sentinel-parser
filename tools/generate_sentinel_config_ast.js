var fs = require("fs");
var path = require("path");
var cp = require("child_process");

console.log(`Running ${__filename}`)

const scriptDir = __dirname;
const root = path.join(scriptDir, "..");
const srcFile = path.join(scriptDir, "sentinel_config_ast_schema.json");
const outFile = path.join(root, "sentinel_config", "ast", "ast.go");

content = "";
schema = JSON.parse(fs.readFileSync(srcFile, { encoding: "utf8" }));

function mungeAsMultilineComment(value) {
  return "// " + value.replace("\n", "\n // ");
}

function mungeAsSingleLineComment(value) {
  return "// " + value.replace("\n", "").trim();
}

function generateType(objSchema) {
  let output = "";
  if (objSchema.description) {
    output += mungeAsMultilineComment(objSchema.description) + "\n";
  }
  output += `type ${objSchema.name} struct {\n`;

  for (let index = 0; index < objSchema.properties.length; index++) {
    prop = objSchema.properties[index];

    output = output + prop.name + " " + prop.type; // + ` \`json:"${prop.name.toLowerCase()}"\``;
    if (prop.description) {
      output += mungeAsSingleLineComment(prop.description);
    }
    output += "\n";
  }

  output += `}\n`;

  return output;
}

function generateHclNode(objSchema) {
  if (objSchema.hclBlockType) {
    // Continue!
  } else {
    return "";
  }

  let blockName = `"${objSchema.hclBlockType}"`
  let blockNameRange = `nil`;

  for (let index = 0; index < objSchema.properties.length; index++) {
    prop = objSchema.properties[index];

    if (prop.hclName) {
      blockName = `o.${prop.name}`;
    }
    if (prop.hclNameRange) {
      blockNameRange = `o.${prop.name}`;
    }
  }

  return `func (o ${objSchema.name}) BlockName() string { return ${blockName} }\n` +
    `func (o ${objSchema.name}) BlockNameRange() *position.SourceRange { return ${blockNameRange} }\n` +
    `func (o ${objSchema.name}) BlockType() string { return "${objSchema.hclBlockType}" }\n`;
}

function generateTypes() {
  output = "";

  for (let index = 0; index < schema.length; index++) {
    output = output + generateType(schema[index]) + "\n";
  }

  return output;
}

function generateNodeRanges() {
  let output = "";

  for (let index = 0; index < schema.length; index++) {
    let range = `nil`;
    let obj = schema[index];

    for (let index2 = 0; index2 < obj.properties.length; index2++) {
      prop = obj.properties[index2];
      if (prop.hclRange) {
        range = `o.${prop.name}`;
      }
    }

    output = output + `func (o ${obj.name}) Range() *position.SourceRange { return ${range} }\n`;
  }

  return output;
}

function generateHclNodes() {
  let output = "";

  for (let index = 0; index < schema.length; index++) {
    let result = generateHclNode(schema[index]);
    output = output + result;
    // if (result !== "") {
    //   output = output + result + "\n";
    // }
  }

  return output;
}

function generateImportSchemas() {
  let output = "";

  for (let index = 0; index < schema.length; index++) {
    if (schema[index].importSchema) {
      output = output + `func (i *${schema[index].name}) Schema() ImportSchema { return ${schema[index].importSchema.toUpperCase()}ImportSchema }\n`;
    }
  }

  return output;
}

content = `package ast

// Autogenerated using generate_sentinel_config_ast.js
// DO NOT MODIFY MANUALLY

import (
	"github.com/glennsarti/sentinel-parser/position"
)

${generateTypes()}
// All nodes must implement Range()
${generateNodeRanges()}
// HCLNode implementations
${generateHclNodes()}
// Import implementations
${generateImportSchemas()}`;

console.log(`Writing ${outFile}...`);
fs.writeFileSync(outFile, content, { encoding: "utf8" });
cp.execSync(`go fmt ${outFile}`);
