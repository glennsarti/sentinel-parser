var fs = require("fs");
var path = require("path");
var cp = require("child_process");

console.log(`Running ${__filename}`)

const scriptDir = __dirname;
const root = path.join(scriptDir, "..");
const srcFile = path.join(scriptDir, "sentinel_config_ast_schema.json");
const outWriteFile = path.join(root, "sentinel_config", "serialization", "json", "json_write_generated.go");
const outReadFile = path.join(root, "sentinel_config", "serialization", "json", "json_read_generated.go");

content = "";
schema = JSON.parse(fs.readFileSync(srcFile, { encoding: "utf8" }));

// Serializing
function generateWriteProperty(propName, propType) {
	switch (propType) {
		case "string":
			return `\tif err := jc.writeLiteralString(${propName}, writer); err != nil { return err }`;

		case "*DynamicValue":
			return `\tif err := jc.writeDynamicValue(${propName}, writer); err != nil { return err }`;

		case "*position.SourceRange":
			return `\tif err := jc.writeSourceRange(${propName}, writer); err != nil { return err }`;

		case "*Test":
		case "*SentinelOptions":
		case "*MockModule":
			return `\tif err := jc.write(${propName}, writer); err != nil { return err }`;

		case "[]string":
			return `\tif err := jc.writeLiteralStringList(${propName}, writer); err != nil { return err }`;

		case "map[string]*Global":
		case "map[string]Import":
		case "map[string]*Mock":
		case "map[string]*Policy":
		case "map[string]*Parameter":
			elementType = propType.substring(11)
			if (elementType.startsWith("*")) {
				elementType = "*ast." + elementType.substring(1)
			} else {
				elementType = "ast." + elementType
			}
			return `\tif err := writeStringMap[${elementType}](${propName}, jc, writer); err != nil { return err }`;

		case "[]*Feature":
		case "[]*TestRule":
			elementType = propType.substring(2)
			if (elementType.startsWith("*")) {
				elementType = "*ast." + elementType.substring(1)
			} else {
				elementType = "ast." + elementType
			}
			return `\tif err := writeList[${elementType}](${propName}, jc, writer); err != nil { return err }`;

		default:
			throw new Error("(generateWriteProperty) Unknown property type: " + propType);
	}
}

function generateWriteType(objSchema) {
	let output = `\nfunc (jc *jsonCoder) write${objSchema.name}(node *ast.${objSchema.name}, writer io.Writer) error {\n` +
		`\tif node == nil {\n` +
		`\t\t_, err := fmt.Fprintf(writer, "null")\n` +
		`\t\treturn err\n` +
		`\t}\n` +
		`\tif err := jc.writeHeader("${objSchema.name}", writer); err != nil { return err }\n`

	for (let index = 0; index < objSchema.properties.length; index++) {
		let prop = objSchema.properties[index];
		let jsonPropName = prop.name.toLowerCase();

		output += `\t// ${prop.name}\n` +
			`\tif _, err := fmt.Fprint(writer, \``
		if (index > 0) { output += "," }
		output += `"${jsonPropName}":\`); err != nil { return err }\n` +
			generateWriteProperty("node." + prop.name, prop.type) + "\n";
	}

	output = output + "\treturn jc.writeFooter(writer)\n" +
		"}\n";

	return output;
}

function generateWriteTypes() {
	let output = "";

	noChildTypes = [];

	for (let index = 0; index < schema.length; index++) {
		output = output + generateWriteType(schema[index]);
	}

	return output;
}

function generateWriteVisitSwitch() {
	let output = "";

	for (let index = 0; index < schema.length; index++) {
		output = output + `\tcase *ast.${schema[index].name}:\n`
		output = output + `\t\treturn jc.write${schema[index].name}(n, writer)\n`
	}

	return output;
}

content = `package json

// Autogenerated using generate_sentinel_ast_walker.js
// DO NOT MODIFY MANUALLY
//
// This is not most effecient or quickest way to serialize to JSON, but it works!

import (
	"fmt"
	"io"

	"github.com/glennsarti/sentinel-parser/sentinel_config/ast"
)

func (jc *jsonCoder) write(node ast.Node, writer io.Writer) error {
	if node == nil {
		return fmt.Errorf("received nil while serializing")
	}

	switch n := node.(type) {
${generateWriteVisitSwitch()}
	default:
		return fmt.Errorf("unexpected node type %T when serializing", node)
	}
}

${generateWriteTypes()}
`;

console.log(`Writing ${outWriteFile}...`);
fs.writeFileSync(outWriteFile, content, { encoding: "utf8" });
cp.execSync(`go fmt ${outWriteFile}`)

// Deserializing
function generateReadVisitSwitch() {
	let output = "";

	for (let index = 0; index < schema.length; index++) {
		output = output + `\tcase "${schema[index].name}":\n`
		output = output + `\t\treturn jc.read${schema[index].name}(raw)\n`
	}

	return output;
}

function generatReadProperty(propName, jsonPropName, propType, className) {
	switch (propType) {
		case "[]string":
		case "string":
			return `\tif val, err := readValue[${propType}](data.Properties["${jsonPropName}"]); err != nil {\n` +
				`\t\treturn nil, fmt.Errorf("could not deserialize '${jsonPropName}' property in '${className}' object: %s", err)\n` +
				`\t} else {\n` +
				`\t\tobj.${propName} = *val\n` +
				`\t}\n`;

		case "*DynamicValue":
		case "*Test":
		case "*SentinelOptions":
		case "*MockModule":
			reader = "read" + propType.substring(1)
			return `\tif raw, err := data.readProperty("${jsonPropName}"); err != nil {\n` +
				`\t\treturn nil, err\n` +
				`\t} else if raw != nil {\n` +
				`\t\tif obj.${propName}, err = jc.${reader}(*raw); err != nil {\n` +
				`\t\t\treturn nil, err\n` +
				`\t\t}\n` +
				`\t}\n`;

		case "*position.SourceRange":
			reader = "readSourceRange"
			return `\tif raw, err := data.readPropertyBytes("${jsonPropName}"); err != nil {\n` +
				`\t\treturn nil, err\n` +
				`\t} else if raw != nil {\n` +
				`\t\tif obj.${propName}, err = jc.${reader}(raw); err != nil {\n` +
				`\t\t\treturn nil, err\n` +
				`\t\t}\n` +
				`\t}\n`;

		case "[]*Feature":
		case "[]*TestRule":
			baseClass = propType.substring(3);
			reader = "read" + baseClass;
			return `\tif raw, err := data.readPropertyBytes("${jsonPropName}"); err != nil {\n` +
				`\t\treturn nil, err\n` +
				`\t} else if raw != nil {\n` +
				`\t\tif val, err := readValueList[ast.${baseClass}](*raw, jc.${reader}); err != nil {\n` +
				`\t\t\treturn nil, err\n` +
				`\t\t} else {\n` +
				`\t\t\tobj.${propName} = *val\n` +
				`\t\t}\n` +
				`\t}\n`;

		case "map[string]*Global":
		case "xxmap[string]Import":
		case "map[string]*Mock":
		case "map[string]*Policy":
		case "map[string]*Parameter":
			baseClass = propType.substring(12);
			reader = "read" + baseClass;
			return `\tif raw, err := data.readPropertyBytes("${jsonPropName}"); err != nil {\n` +
				`\t\treturn nil, err\n` +
				`\t} else if raw != nil {\n` +
				`\t\tif val, err := readValueStringMapPointer[ast.${baseClass}](*raw, jc.${reader}); err != nil {\n` +
				`\t\t\treturn nil, err\n` +
				`\t\t} else {\n` +
				`\t\t\tobj.${propName} = *val\n` +
				`\t\t}\n` +
				`\t}\n`;

		// Imports area special case because they're an interface
		case "map[string]Import":
			baseClass = propType.substring(11);
			reader = "read" + baseClass;
			return `\tif raw, err := data.readPropertyBytes("${jsonPropName}"); err != nil {\n` +
				`\t\treturn nil, err\n` +
				`\t} else if raw != nil {\n` +
				`\t\tif val, err := readValueStringMap[ast.${baseClass}](*raw, jc.${reader}); err != nil {\n` +
				`\t\t\treturn nil, err\n` +
				`\t\t} else {\n` +
				`\t\t\tobj.${propName} = *val\n` +
				`\t\t}\n` +
				`\t}\n`;

		default:
			throw new Error("(generatReadProperty) Unknown property type: " + prop.type);
	}
}

function generateReadType(objSchema) {
	let output =
		`\nfunc(jc * jsonCoder) read${objSchema.name}(data rawJsonObject) (*ast.${objSchema.name}, error) {` +
		`\n\tjc.tracer.PushMethod("read${objSchema.name}", "")` +
		`\n\tdefer jc.tracer.PopMethod("read${objSchema.name}")\n` +
		`\n\tif data.AstType != "${objSchema.name}" {` +
		`\n\t\treturn nil, fmt.Errorf("expected '_t' property in '${objSchema.name}' object to be '${objSchema.name}' but got %q", data.AstType)` +
		`\n\t}` +
		`\n\tobj := ast.${objSchema.name}{}\n\n`;

	for (let index = 0; index < objSchema.properties.length; index++) {
		let prop = objSchema.properties[index];
		let jsonPropName = prop.name.toLowerCase();

		output += `\t// ${prop.name}\n` +
			`\tjc.tracer.Trace("Reading ${prop.name}")\n` +
			generatReadProperty(prop.name, jsonPropName, prop.type, objSchema.name) + `\n`;
	}

	output = output + "\treturn &obj, nil\n" +
		"}\n";

	return output;
}

function generateReadIntoTypes() {
	let output = "";

	for (let index = 0; index < schema.length; index++) {
		objSchema = schema[index];

		output = output + `\tcase *ast.${objSchema.name}:\n` +
			`\t\tif resultActual, ok := result.(*ast.${objSchema.name}); !ok {\n` +
			`\t\t\treturn fmt.Errorf("Expected to decode a ${objSchema.name} but it was not")\n` +
			`\t\t} else {\n`
		for (let index = 0; index < objSchema.properties.length; index++) {
			let prop = objSchema.properties[index];
			let jsonPropName = prop.name.toLowerCase();

			output += `\t\t\tintoActual.${prop.name} = resultActual.${prop.name}\n`;
		}
		output += `\t\t}\n`
	}

	return output;
}

function generateReadTypes() {
	let output = "";

	noChildTypes = [];

	for (let index = 0; index < schema.length; index++) {
		output = output + generateReadType(schema[index]);
	}

	return output;
}

function generateReadImportTypes() {
	let output = "";

	for (let index = 0; index < schema.length; index++) {
		if (schema[index].importSchema) {
			output = output + `\tcase "${schema[index].name}":\n` +
				`\t\treturn jc.read${schema[index].name}(data)\n`
		}
	}

	return output;
}

content = `package json

// Autogenerated using generate_sentinel_ast_walker.js
// DO NOT MODIFY MANUALLY
//
// This is not most effecient or quickest way to deserialize from JSON
// to an AST, but it works!

import (
	"encoding/json"
	"fmt"

	"github.com/glennsarti/sentinel-parser/sentinel_config/ast"
)

type rawJsonObject struct {
	AstType    string                     \`json:"_t"\`
	Properties map[string]json.RawMessage \`json:"_p"\`
}

func (jc *jsonCoder) read(data []byte) (ast.Node, error) {
	raw := rawJsonObject{}
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	switch raw.AstType {
${generateReadVisitSwitch()}
	default:
		return nil, fmt.Errorf("Unknown type %q while deserializing", raw.AstType)
	}
}

func (jc *jsonCoder) readInto(data []byte, into ast.Node) error {
	result, err := jc.read(data)
	if err != nil {
		return err
	}

	switch intoActual := into.(type) {
${generateReadIntoTypes()}
	default:
		return fmt.Errorf("Unknown type %T while deserializing", intoActual)
	}

	return nil
}

${generateReadTypes()}
func (jc *jsonCoder) readImport(data rawJsonObject) (ast.Import, error) {
	switch data.AstType {
${generateReadImportTypes()}
	default:
		return nil, fmt.Errorf("Unknown type import %q while deserializing", data.AstType)
	}
}
`;

console.log(`Writing ${outReadFile}...`);
fs.writeFileSync(outReadFile, content, { encoding: "utf8" });
cp.execSync(`go fmt ${outReadFile}`);
